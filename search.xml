<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Python 字符串格式化]]></title>
    <url>%2F2018%2F02%2F12%2FPython%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%A0%BC%E5%BC%8F%E5%8C%96%2F</url>
    <content type="text"><![CDATA[Python 有两种格式化字符串的方式，我们习惯简单地称之为旧式(old style)和新式(new style)。这两种方式在 Python 2 和 Python 3 中都适用(新式格式化方法适用于 Python 2.6 及 以上)。 使用%的旧式格式化旧式格式化的形式为 string % data。其中 string 包含的是待插值的序列。 完整语法格式： 1%[(name)][flags][width].[precision]typecode (name)：可选，用于选择指定的key flags：可选，可供选择的值有: +： 右对齐；正数前加正好，负数前加负号； -： 左对齐；正数前无符号，负数前加负号； 空格：右对齐；正数前加空格，负数前加负号； 0： 右对齐；正数前无符号，负数前加负号；用0填充空白处 width： 可选，占有宽度 .precision：可选，小数点后保留的位数 typecode：必选（参见下表） ​ 一些常见的插值序列 格式化字符 转换方式 %s 字符串 %d 十进制整数 %x 十六进制整数 %o 八进制整数 %f 十进制浮点数 %e 以科学计数法表示的浮点数 %g 十进制或科学计数法表示的浮点数 %% 文本值%本身 下面是一些简单的例子。首先格式化一个整数: 12345678&gt;&gt;&gt; '%s' % 42 '42'&gt;&gt;&gt; '%d' % 42 '42'&gt;&gt;&gt; '%x' % 42 '2a'&gt;&gt;&gt; '%o' % 42 '52' 接着是浮点数: 12345678&gt;&gt;&gt; '%s' % 7.03 '7.03'&gt;&gt;&gt; '%f' % 7.03 '7.030000'&gt;&gt;&gt; '%e' % 7.03 '7.030000e+00' &gt;&gt;&gt; '%g' % 7.03 '7.03' 整数和字面值 %: 12&gt;&gt;&gt; '%d%%' % 100 '100%' 下面是一些关于字符串和整数的插值操作: 123456789&gt;&gt;&gt; actor = 'Richard Gere' &gt;&gt;&gt; cat = 'Chester'&gt;&gt;&gt; weight = 28&gt;&gt;&gt; "My wife's favorite actor is %s" % actor"My wife's favorite actor is Richard Gere"&gt;&gt;&gt; "Our cat %s weighs %s pounds" % (cat, weight) 'Our cat Chester weighs 28 pounds' 字符串内的 %s 意味着需要插入一个字符串。字符串中出现 % 的次数需要与 % 之后所提供的 数据项个数相同。 如果只需插入一个数据，例如前面的 actor，直接将需要插入的数据置于 % 后即可。 如果需要插入多个数据，则需要将它们封装进一个元组(以圆括号为界，逗号 分开)，例如上例中的 (cat, weight)。 尽管 weight 是一个整数，格式化串中的 %s 也会将它转化为字符串型。 你可以在 % 和指定类型的字母之间设定最大和最小宽度、排版以及填充字符，等等。 我们来定义一个整数 n、一个浮点数 f 以及一个字符串 s: 123&gt;&gt;&gt; n = 42&gt;&gt;&gt; f = 7.03&gt;&gt;&gt; s = 'string cheese' 使用默认宽度格式化它们: 12&gt;&gt;&gt; '%d %f %s' % (n, f, s) '42 7.030000 string cheese' 为每个变量设定最小域宽为 10 个字符，右对齐，左侧不够用空格填充: 12&gt;&gt;&gt; '%10d %10f %10s' % (n, f, s)' 42 7.030000 string cheese' 和上面的例子使用同样的域宽，但改成左对齐: 12&gt;&gt;&gt; '%-10d %-10f %-10s' % (n, f, s)'42 7.030000 string cheese' 这次仍然使用之前的域宽，但是设定最大字符宽度为 4，右对齐。 这样的设置会截断超过 长度限制的字符串，并且将浮点数的精度限制在小数点后 4 位: 12&gt;&gt;&gt; '%10.4d %10.4f %10.4s' % (n, f, s) ' 0042 7.0300 stri' 去掉最小域宽为 10 的限制: 12&gt;&gt;&gt; '%.4d %.4f %.4s' % (n, f, s) '0042 7.0300 stri' 最后，改变一下上面例子的硬编码方式，将域宽、字符宽度等设定作为参数: 12&gt;&gt;&gt; '%*.*d %*.*f %*.*s' % (10, 4, n, 10, 4, f, 10, 4, s) ' 0042 7.0300 stri' 使用{}和format的新式格式化如果你在使用 Python 3，新式格式化更值得推荐。 新式格式化最简单的用法如下所示: 12&gt;&gt;&gt; '&#123;&#125; &#123;&#125; &#123;&#125;'.format(n, f, s) '42 7.03 string cheese' 旧式格式化中传入参数的顺序需要与 % 占位符出现的顺序完全一致， 但在新式格式化里， 可以自己指定插入的顺序: 12&gt;&gt;&gt; '&#123;2&#125; &#123;0&#125; &#123;1&#125;'.format(f, s, n) '42 7.03 string cheese' 0 代表第一个参数 f; 1 代表字符串 s; 2 代表最后一个参数，整数 n。 参数可以是字典或者命名变量，格式串中的标识符可以引用这些名称: 12&gt;&gt;&gt; '&#123;n&#125; &#123;f&#125; &#123;s&#125;'.format(n=42, f=7.03, s='string cheese') '42 7.03 string cheese' 下面的例子中，我们试着将之前作为参数的 3 个值存到一个字典中，如下所示: 1&gt;&gt;&gt; d = &#123;'n': 42, 'f': 7.03, 's': 'string cheese'&#125; 下面的例子中，{0} 代表整个字典，{1} 则代表字典后面的字符串 ‘other’: 12&gt;&gt;&gt; '&#123;0[n]&#125; &#123;0[f]&#125; &#123;0[s]&#125; &#123;1&#125;'.format(d, 'other')'42 7.03 string cheese other' 上面这些例子都是以默认格式打印结果的。 旧式格式化允许在 % 后指定参数格式，但在新式格式化里，将这些格式标识符放在 : 后。首先使用位置参数的例子: 12&gt;&gt;&gt; '&#123;0:d&#125; &#123;1:f&#125; &#123;2:s&#125;'.format(n, f, s)'42 7.030000 string cheese' 接着使用相同的值，但这次它们作为命名参数: 12&gt;&gt;&gt; '&#123;n:d&#125; &#123;f:f&#125; &#123;s:s&#125;'.format(n=42, f=7.03, s='string cheese') '42 7.030000 string cheese' 新式格式化也支持其他各类设置(最小域宽、最大字符宽、排版，等等)。 下面是一个最小域宽设为 10、右对齐(默认)的例子: 12&gt;&gt;&gt; '&#123;0:10d&#125; &#123;1:10f&#125; &#123;2:10s&#125;'.format(n, f, s) ' 42 7.030000 string cheese' 与上面例子一样，但使用 &gt; 字符设定右对齐显然要更为直观: 12&gt;&gt;&gt; '&#123;0:&gt;10d&#125; &#123;1:&gt;10f&#125; &#123;2:&gt;10s&#125;'.format(n, f, s)' 42 7.030000 string cheese' 最小域宽为 10，左对齐: 12&gt;&gt;&gt; '&#123;0:&lt;10d&#125; &#123;1:&lt;10f&#125; &#123;2:&lt;10s&#125;'.format(n, f, s)'42 7.030000 string cheese' 最小域宽为 10，居中: 12&gt;&gt;&gt; '&#123;0:^10d&#125; &#123;1:^10f&#125; &#123;2:^10s&#125;'.format(n, f, s)' 42 7.030000 string cheese' 新式格式化与旧式格式化相比有一处明显的不同：精度(precision，小数点后面的数字) 对于浮点数而言仍然代表着小数点后的数字个数， 对于字符串而言则代表着最大字符个 数，但在新式格式化中你无法对整数设定精度: 1234&gt;&gt;&gt; '&#123;0:&gt;10.4d&#125; &#123;1:&gt;10.4f&#125; &#123;2:10.4s&#125;'.format(n, f, s) Traceback (most recent call last):File "&lt;stdin&gt;", line 1, in &lt;module&gt;ValueError: Precision not allowed in integer format specifier 最后一个可设定的值是填充字符。如果想要使用空格以外的字符进行填充，只需把它放 在 :之后，其余任何排版符（&lt;、&gt;、^）和宽度标识符之前即可: 12&gt;&gt;&gt; '&#123;0:!^20s&#125;'.format('BIG SALE') '!!!!!!BIG SALE!!!!!!']]></content>
      <categories>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Python None]]></title>
    <url>%2F2018%2F02%2F12%2FPythonNone%2F</url>
    <content type="text"><![CDATA[None 是 Python 中一个特殊的值，虽然它不表示任何数据，但仍然具有重要的作用。 虽然 None 作为布尔值和 False 是一样的，但是它和 False 有很多差别。下面是一个 例子： 1234567&gt;&gt;&gt; thing = None&gt;&gt;&gt; if thing:... print("It's some thing")... else:... print("It's no thing")...It's no thing 为了区分 None 和布尔值 False , 使用 Python 的 is 操作符: 123456&gt;&gt;&gt; if thing is None:... print("It's nothing")... else:... print("It's something")...It's nothing 这虽然是一个微妙的区别，但是对于 Python 来说是很重要的。 你需要把 None 和不含 任何值的空数据结构区分开来。0 值的整型 / 浮点型、空字符串&#39;&#39;、空列表[]、 空元组(,)、空字典{}、空集合set()都等价于 False，但是不等于 None。 定义一个函数，输出它的参数是否是 None： 1234567def is_none(thing): if thing is None: print("It's None") elif thing: print("It's True") else: print("It's False") 测试： 123456789101112131415161718&gt;&gt;&gt; is_none(None)It's None&gt;&gt;&gt; is_none(True)It's True&gt;&gt;&gt; is_none(False)It's False&gt;&gt;&gt; is_none(0)It's False&gt;&gt;&gt; is_none(0.0)It's False&gt;&gt;&gt; is_none(())It's False&gt;&gt;&gt; is_none([])It's False&gt;&gt;&gt; is_none(&#123;&#125;)It's False&gt;&gt;&gt; is_none(set())It's False]]></content>
      <categories>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Python函数]]></title>
    <url>%2F2018%2F02%2F12%2FPython%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[入门最简单的 Python 函数： 12&gt;&gt;&gt; def do_nothing():... pass 函数命名规范和变量命名一样（必须使用字母或者下划线 _ 开头，仅能含 有字母、数字和下划线） 调用： 12&gt;&gt;&gt; do_nothing()&gt;&gt;&gt; 定义一个无参但有返回值的函数: 12&gt;&gt;&gt; def agree():... return True 定义一个有参有返回值的函数: 12&gt;&gt;&gt; def echo(anything):... return anything + ' ' + anything 调用echo() 12&gt;&gt;&gt; echo('Rumplestiltskin')'Rumplestiltskin Rumplestiltskin' 传入到函数的值称为参数。当调用含参数的函数时，这些参数的值会被复制给函数中的对 应参数。 在之前的例子中，被调用的函数 echo()的传入参数字符串是 ‘Rumplestiltskin’， 这个值被复制给参数 anything ， 然后返回到调用方。 一个函数可以接受任何数量（包括 0）的任何类型的值作为输入变量，并且返回任何数量 （包括 0）的任何类型的结果。 如果函数不显式调用 return 函数，那么会默认返回 None。 位置参数Python 处理参数的方式要比其他语言更加灵活。其中，最熟悉的参数类型是位置参数，传入参数的值是按照顺序依次复制过去的。下面创建一个带有位置参数的函数，并且返回一个字典: 12def menu(wine, entree, dessert): return &#123;'wine': wine, 'entree': entree, 'dessert': dessert&#125; 12&gt;&gt;&gt; menu('chardonnay', 'chicken', 'cake')&#123;'dessert': 'cake', 'wine': 'chardonnay', 'entree': 'chicken'&#125; 尽管这种方式很常见，但是位置参数的一个弊端是必须熟记每个位置的参数的含义。在调 用函数menu() 时误把最后一个参数当作第一个参数，会得到完全不同的结果: 12&gt;&gt;&gt; menu('beef', 'bagel', 'bordeaux')&#123;'dessert': 'bordeaux', 'wine': 'beef', 'entree': 'bagel'&#125; 关键字参数为了避免位置参数带来的混乱，调用参数时可以指定对应参数的名字，甚至可以采用与函数定义不同的顺序调用: 12&gt;&gt;&gt; menu(entree='beef', dessert='bagel', wine='bordeaux') &#123;'dessert': 'bagel', 'wine': 'bordeaux', 'entree': 'beef'&#125; 你也可以把位置参数和关键字参数混合起来。首先，实例化参数 wine，然后对参数 entree 和 dessert 使用关键字参数的方式: 12&gt;&gt;&gt; menu('frontenac', dessert='flan', entree='fish') &#123;'entree': 'fish', 'dessert': 'flan', 'wine': 'frontenac'&#125; 如果同时出现两种参数形式，首先应该考虑的是位置参数。 指定默认参数值当调用方没有提供对应的参数值时，你可以指定默认参数值。 12def menu(wine, entree, dessert='pudding'): return &#123;'wine': wine, 'entree': entree, 'dessert': dessert&#125; 这一次调用不带 dessert 参数的函数 menu(): 12&gt;&gt;&gt; menu('chardonnay', 'chicken')&#123;'dessert': 'pudding', 'wine': 'chardonnay', 'entree': 'chicken'&#125; 如果你提供参数值，在调用时会代替默认值: 12&gt;&gt;&gt; menu('dunkelfelder', 'duck', 'doughnut')&#123;'dessert': 'doughnut', 'wine': 'dunkelfelder', 'entree': 'duck'&#125; 默认参数值在函数被定义时已经计算出来，而不是在程序运行时。 Python 程 序员经常犯的一个错误是把可变的数据类型(例如列表或者字典)当作默认 参数值。 在下面的例子中，函数buggy() 在每次调用时，添加参数 arg 到一个空的列表 result，然 后打印输出一个单值列表。 但是存在一个问题：只有在第一次调用时列表是空的，第二次 调用时就会存在之前调用的返回值: 123def buggy(arg, result=[]): result.append(arg) print(result) 1234&gt;&gt;&gt; buggy('a')['a']&gt;&gt;&gt; buggy('b') # expect ['b'] ['a', 'b'] 如果写成下面的样子就会解决刚才的问题: 1234def works(arg): result = [] result.append(arg) return result 1234&gt;&gt;&gt; works('a')['a']&gt;&gt;&gt; works('b')['b'] 也可以修改为：如果是第一次调用就跳过一些操作: 12345def nonbuggy(arg, result=None): if result is None: result = [] result.append(arg) print(result) 1234&gt;&gt;&gt; nonbuggy('a') ['a']&gt;&gt;&gt; nonbuggy('b') ['b'] 设置默认参数时，有几点要注意： 默认参数必须指向不可变对象！ 必选参数在前，默认参数在后，否则Python的解释器会报错； 如何定义默认参数？ 当函数有多个参数时，把变化大的参数放前面，变化小的参数放后面。变化小的参数就可以作为默认参数。 使用*收集位置参数在Python函数中，还可以定义可变参数。顾名思义，可变参数就是传入的参数个数是可变的，可以是1个、2个到任意个，还可以是0个。 我们以数学题为例子，给定一组数字a，b，c……，请计算a2 + b2 + c2 + ……。 要定义出这个函数，我们必须确定输入的参数。由于参数个数不确定，我们首先想到可以把a，b，c……作为一个list或tuple传进来，这样，函数可以定义如下： 12345def calc(numbers): sum = 0 for n in numbers: sum = sum + n * n return sum 但是调用的时候，需要先组装出一个list或tuple： 1234&gt;&gt;&gt; calc([1, 2, 3])14&gt;&gt;&gt; calc((1, 3, 5, 7))84 如果利用可变参数，调用函数的方式可以简化成这样： 1234&gt;&gt;&gt; calc(1, 2, 3)14&gt;&gt;&gt; calc(1, 3, 5, 7)84 所以，我们把函数的参数改为可变参数： 12345def calc(*numbers): sum = 0 for n in numbers: sum = sum + n * n return sum 定义可变参数和定义一个list或tuple参数相比，仅仅在参数前面加了一个*号。在函数内部，参数numbers接收到的是一个tuple，因此，函数代码完全不变。 但是，调用该函数时，可以传入任意个参数，包括0个参数： 1234&gt;&gt;&gt; calc(1, 2)5&gt;&gt;&gt; calc()0 如果已经有一个list或者tuple，要调用一个可变参数怎么办？可以这样做： 123&gt;&gt;&gt; nums = [1, 2, 3]&gt;&gt;&gt; calc(nums[0], nums[1], nums[2])14 这种写法当然是可行的，问题是太繁琐，所以Python允许你在list或tuple前面加一个*号，把list或tuple的元素变成可变参数传进去： 123&gt;&gt;&gt; nums = [1, 2, 3]&gt;&gt;&gt; calc(*nums)14 *nums表示把nums这个list的所有元素作为可变参数传进去。这种写法相当有用，而且很常见。 使用**收集关键字参数关键字参数允许你传入0个或任意个含参数名的参数，这些关键字参数在函数内部自动组装为一个dict。请看示例： 12def person(name, age, **kw): print('name:', name, 'age:', age, 'other:', kw) 函数person除了必选参数name和age外，还接受关键字参数kw。 在调用该函数时，可以只传入必选参数： 12&gt;&gt;&gt; person('Michael', 30)name: Michael age: 30 other: &#123;&#125; 也可以传入任意个数的关键字参数： 1234&gt;&gt;&gt; person('Bob', 35, city='Beijing')name: Bob age: 35 other: &#123;'city': 'Beijing'&#125;&gt;&gt;&gt; person('Adam', 45, gender='M', job='Engineer')name: Adam age: 45 other: &#123;'gender': 'M', 'job': 'Engineer'&#125; 关键字参数有什么用？ 它可以扩展函数的功能。比如，在person函数里，我们保证能接收到name和age这两个参数，但是，如果调用者愿意提供更多的参数，我们也能收到。 试想你正在做一个用户注册的功能，除了用户名和年龄是必填项外，其他都是可选项，利用关键字参数来定义这个函数就能满足注册的需求。 和可变参数类似，也可以先组装出一个dict，然后，把该dict转换为关键字参数传进去： 123&gt;&gt;&gt; extra = &#123;'city': 'Beijing', 'job': 'Engineer'&#125;&gt;&gt;&gt; person('Jack', 24, city=extra['city'], job=extra['job'])name: Jack age: 24 other: &#123;'city': 'Beijing', 'job': 'Engineer'&#125; 当然，上面复杂的调用可以用简化的写法： 123&gt;&gt;&gt; extra = &#123;'city': 'Beijing', 'job': 'Engineer'&#125;&gt;&gt;&gt; person('Jack', 24, **extra)name: Jack age: 24 other: &#123;'city': 'Beijing', 'job': 'Engineer'&#125; **extra表示把extra这个dict的所有key-value用关键字参数传入到函数的**kw参数，kw将获得一个dict，注意kw获得的dict是extra的一份拷贝，对kw的改动不会影响到函数外的extra。 命名关键字参数对于关键字参数，函数的调用者可以传入任意不受限制的关键字参数。至于到底传入了哪些，就需要在函数内部通过kw检查。 仍以person()函数为例，我们希望检查是否有city和job参数： 12345678def person(name, age, **kw): if 'city' in kw: # 有city参数 pass if 'job' in kw: # 有job参数 pass print('name:', name, 'age:', age, 'other:', kw) 但是调用者仍可以传入不受限制的关键字参数： 1&gt;&gt;&gt; person('Jack', 24, city='Beijing', addr='Chaoyang', zipcode=123456) 如果要限制关键字参数的名字，就可以用命名关键字参数，例如，只接收city和job作为关键字参数。这种方式定义的函数如下： 12def person(name, age, *, city, job): print(name, age, city, job) 和关键字参数**kw不同，命名关键字参数需要一个特殊分隔符*，*后面的参数被视为命名关键字参数。 调用方式如下： 12&gt;&gt;&gt; person('Jack', 24, city='Beijing', job='Engineer')Jack 24 Beijing Engineer 如果函数定义中已经有了一个可变参数，后面跟着的命名关键字参数就不再需要一个特殊分隔符*了： 12def person(name, age, *args, city, job): print(name, age, args, city, job) 命名关键字参数必须传入参数名，这和位置参数不同。如果没有传入参数名，调用将报错： 1234&gt;&gt;&gt; person('Jack', 24, 'Beijing', 'Engineer')Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;TypeError: person() takes 2 positional arguments but 4 were given 由于调用时缺少参数名city和job，Python解释器把这4个参数均视为位置参数，但person()函数仅接受2个位置参数。 命名关键字参数可以有缺省值，从而简化调用： 12def person(name, age, *, city='Beijing', job): print(name, age, city, job) 由于命名关键字参数city具有默认值，调用时，可不传入city参数： 12&gt;&gt;&gt; person('Jack', 24, job='Engineer')Jack 24 Beijing Engineer 参数组合在Python中定义函数，可以用必选参数、默认参数、可变参数、关键字参数和命名关键字参数，这5种参数都可以组合使用。 但是请注意，参数定义的顺序必须是：必选参数、默认参数、可变参数、命名关键字参数和关键字参数。 比如定义一个函数，包含上述若干种参数： 12345def f1(a, b, c=0, *args, **kw): print('a =', a, 'b =', b, 'c =', c, 'args =', args, 'kw =', kw)def f2(a, b, c=0, *, d, **kw): print('a =', a, 'b =', b, 'c =', c, 'd =', d, 'kw =', kw) 在函数调用的时候，Python解释器自动按照参数位置和参数名把对应的参数传进去。 12345678910&gt;&gt;&gt; f1(1, 2)a = 1 b = 2 c = 0 args = () kw = &#123;&#125;&gt;&gt;&gt; f1(1, 2, c=3)a = 1 b = 2 c = 3 args = () kw = &#123;&#125;&gt;&gt;&gt; f1(1, 2, 3, 'a', 'b')a = 1 b = 2 c = 3 args = ('a', 'b') kw = &#123;&#125;&gt;&gt;&gt; f1(1, 2, 3, 'a', 'b', x=99)a = 1 b = 2 c = 3 args = ('a', 'b') kw = &#123;'x': 99&#125;&gt;&gt;&gt; f2(1, 2, d=99, ext=None)a = 1 b = 2 c = 0 d = 99 kw = &#123;'ext': None&#125; 最神奇的是通过一个tuple和dict，你也可以调用上述函数： 12345678&gt;&gt;&gt; args = (1, 2, 3, 4)&gt;&gt;&gt; kw = &#123;'d': 99, 'x': '#'&#125;&gt;&gt;&gt; f1(*args, **kw)a = 1 b = 2 c = 3 args = (4,) kw = &#123;'d': 99, 'x': '#'&#125;&gt;&gt;&gt; args = (1, 2, 3)&gt;&gt;&gt; kw = &#123;'d': 88, 'x': '#'&#125;&gt;&gt;&gt; f2(*args, **kw)a = 1 b = 2 c = 3 d = 88 kw = &#123;'x': '#'&#125; 所以，对于任意函数，都可以通过类似func(*args, **kw)的形式调用它，无论它的参数是如何定义的。 文档字符串程序的可读性很重要。建议在函数体开始的部分附上函数定义说明的文档，这就是函数的文档字符串: 123def echo(anything): 'echo returns its input argument' return anything 调用 Python 函数help()可以打印输出一个函数的文档字符串。 12345&gt;&gt;&gt; help(echo)Help on function echo in module __main__: echo(anything)echo returns its input argument 如果仅仅想得到文档字符串: 12&gt;&gt;&gt; print(echo.__doc__)echo returns its input argument 作为参数的函数为了测试，现在定义一个简单的函数 answer()， 12def answer(): print(42) 再定义一个函数run_something()。它有一个参数func，这个参数是一个可以运行的函数的 名字: 12def run_something(func): func() 将函数 answer 传到该函数，在这里像之前碰到的一样，把函数名当作数据使用: 12&gt;&gt;&gt; run_something(answer)42 注意，你传给函数的是 answer ， 而不是 answer()。 在 Python 中圆括号意味着调用函数。在 没有圆括号的情况下，Python 会把函数当作普通对象。 12&gt;&gt;&gt; type(run_something) &lt;class 'function'&gt; 我们来运行一个带参数的例子。定义函数 add_args()： 12def add_args(arg1, arg2): print(arg1 + arg2) 此刻定义一个函数 run_something_with_args()，它带有三个参数: func——可以运行的函数 arg1——func 函数的第一个参数 arg2——func 函数的第二个参数 12def run_something_with_args(func, arg1, arg2): func(arg1, arg2) 当调用run_something_with_args() 时，调用方传来的函数赋值给 func 参数，而 arg1 和 arg2 从参数列表中获得值。然后运行带参数的 func(arg1, arg2)。 12&gt;&gt;&gt; run_something_with_args(add_args, 5, 9)14 在函数run_something_with_args()内部，函数名 add_args 被赋值给参数func，5 和 9 分别赋值给 arg1 和arg2。程序最后执行 1add_args(5, 9) 同样可以在此用上 *args(位置参数收集)和**kwargs(关键字参数收集)的技巧。 我们定义一个测试函数，它可以接受任意数量的位置参数，使用 sum() 函数计算它们的和并返回： 12def sum_args(*args): return sum(args) 下面再定义一个新的函数run_with_positional_args() , 接收一个函数名以及任意数量的位 置参数: 12def run_with_positional_args(func, *args): return func(*args) 现在直接调用它: 12&gt;&gt;&gt; run_with_positional_args(sum_args, 1, 2, 3, 4)10 同样可以把函数作为列表、元组、集合和字典的元素。函数名是不可变的，因此可以把函 数用作字典的键。 内部函数在 Python 中，可以在函数中定义另外一个函数: 1234def outer(a, b): def inner(c, d): return c + d return inner(a, b) 12&gt;&gt;&gt; outer(4, 7)11 当需要在函数内部多次执行复杂的任务时，内部函数是非常有用的，从而避免了循环和代 码的堆叠重复。 对于这样一个字符串的例子，内部函数的作用是给外部的函数增加字符串 参数: 1234def knights(saying): def inner(quote): return "We are the knights who say: '%s'" % quote return inner(saying) 12&gt;&gt;&gt; knights('Ni!')"We are the knights who say: 'Ni!'" 作为返回值的函数我们来实现一个可变参数的求和。通常情况下，求和的函数是这样定义的： 12345def calc_sum(*args): ax = 0 for n in args: ax = ax + n return ax 但是，如果不需要立刻求和，而是在后面的代码中，根据需要再计算怎么办？可以不返回求和的结果，而是返回求和的函数： 1234567def lazy_sum(*args): def sum(): ax = 0 for n in args: ax = ax + n return ax return sum 闭包内部函数可以看作一个闭包。闭包是一个可以由另一个函数动态生成的函数，并且可以改变和存储函数外创建的变量的值。 下面的例子以之前的 knights() 为基础。现在，调用新的函数 knight2()，把 inner() 函数 变成一个叫inner2()的闭包。可以看出有以下不同点。 inner2() 直接使用外部的 saying 参数，而不是通过另外一个参数获取。 knights2() 返回值为inner2 函数，而不是调用它。 1234def knights2(saying): def inner2(): return "We are the knights who say: '%s'" % saying return inner2 inner2() 函数可以得到 saying 参数的值并且记录下来。 return inner2 这一行返回的是 inner2 函数的复制(没有直接调用)。 所以它就是一个闭包：一个被动态创建的可以记录 外部变量的函数。 用不同的参数调用knights2() 两次: 12&gt;&gt;&gt; a = knights2('Duck')&gt;&gt;&gt; b = knights2('Hasenpfeffer') 那么 a 和 b 会是什么类型? 1234&gt;&gt;&gt; type(a)&lt;class 'function'&gt; &gt;&gt;&gt; type(b)&lt;class 'function'&gt; 它们是函数，同时也是闭包: 1234&gt;&gt;&gt; a&lt;function knights2.&lt;locals&gt;.inner2 at 0x10193e158&gt;&gt;&gt;&gt; b&lt;function knights2.&lt;locals&gt;.inner2 at 0x10193e1e0&gt; 如果调用它们，它们会记录被 knights2 函数创建时的外部变量 saying: 1234&gt;&gt;&gt; a()"We are the knights who say: 'Duck'"&gt;&gt;&gt; b()"We are the knights who say: 'Hasenpfeffer'" 匿名函数：lambda()当我们在传入函数时，有些时候，不需要显式地定义函数，直接传入匿名函数更方便。 语法格式： 1lambda x: x * x 实际上就是： 12def f(x): return x * x 关键字lambda表示匿名函数，冒号前面的x表示函数参数。 匿名函数有个限制，就是只能有一个表达式，不用写return，返回值就是该表达式的结果。 匿名函数也是一个函数对象，也可以把匿名函数赋值给一个变量，再利用变量来调用该函数： 12345&gt;&gt;&gt; f = lambda x: x * x&gt;&gt;&gt; f&lt;function &lt;lambda&gt; at 0x101c6ef28&gt;&gt;&gt;&gt; f(5)25 同样，也可以把匿名函数作为返回值返回，比如： 12def build(x, y): return lambda: x * x + y * y 12 12 12]]></content>
      <categories>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Python 迭代器和推导式]]></title>
    <url>%2F2018%2F02%2F11%2FPython%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8C%E6%8E%A8%E5%AF%BC%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[迭代器和 iter() 函数迭代(Iteration)用简单的话讲，它就是从某个地方（比如一个列表）取出一个元素的过程。当我们使用一个循环来遍历某个东西时，这个过程本身就叫迭代。 可迭代对象(Iterable)Python中任意的对象，只要它定义了可以返回一个迭代器的__iter__方法，或者定义了可以支持下标索引的__getitem__方法，那么它就是一个可迭代对象。简单说，可迭代对象就是能提供迭代器的任意对象。 迭代器(Iterator)任意对象，只要定义了next()(Python2) 或者__next__方法，它就是一个迭代器。 它为类序列对象提供了一个类序列的接口。 你可以迭代不是序列但表现出序列行为的对象，例如字典的 key ， 一个 文件的行， 等等。 当你使用循环迭代一个对象条目时，你几乎不可能分辨出它是迭代器还是序列。你不必去关注这些，因为 Python 让它象一个序列那样操作。 当你或是一个循 环机制(例如 for 语句)需要下一个项时，调用迭代器的 next() 方法就可以获得它。条目全部取 出后， 会引发一个 StopIteration 异常， 这并不表示错误发生，只是告诉外部调用者， 迭代完成。 不过，迭代器也有一些限制。例如你不能向后移动，不能回到开始，也不能复制一个迭代器。如果你要再次(或者是同时)迭代同个对象， 你只能去创建另一个迭代器对象。 reversed() 内建函数将返回一个反序访问的迭代器。 enumerate() 内建函数同样也返回迭代器。 另外两个新的内建函数。 any() 和 all() ，如果迭代器中某个/所有条目 的值都为布尔真时，则它们返回值为真。 如何创建迭代器对一个对象调用 iter() 就可以得到它的迭代器。 12iter(obj)iter(func, sentinel ) 如果你传递一个参数给iter() ，它会检查你传递的是不是一个序列，如果是， 那么很简单: 根据索引从 0 一直迭代到序列结束。 另一个创建迭代器的方法是使用类, 我们将在面向对象中详细 介绍：一个实现了 __iter__() 和 next()方法的类可以作为迭代器使用. 如果是传递两个参数给 iter() ， 它会重复地调用 func，直到迭代器的下个值等于 sentinel . 使用迭代器序列迭代 Python 的序列对象 123456789101112&gt;&gt;&gt; myTuple = (123, 'xyz', 45.67)&gt;&gt;&gt; i = iter(myTuple)&gt;&gt;&gt; i.next()123&gt;&gt;&gt; i.next()'xyz'&gt;&gt;&gt; i.next()45.67&gt;&gt;&gt; i.next()Traceback (most recent call last):File "", line 1, in ?StopIteration 如果这是一个实际应用程序，那么我们需要把代码放在一个try-except 块中。序列现在会自 动地产生它们自己的迭代器，所以一个 for 循环: 12for i in seq: do_something_to(i) 实际上是这样工作的: 1234567fetch = iter(seq)while True: try: i = fetch.next() except StopIteration: break do_something_to(i) for 循环会自动调用迭代器的 next() 方法(以及监视 StopIteration 异常). 字典字典和文件是另外两个可迭代的 Python 数据类型。字典的迭代器会遍历它的键(keys)。语句 for eachKey in myDict.keys() 可以缩写为for eachKey in myDict 另外， Python 还引进了三个新的内建字典方法来定义迭代： myDict.iterkeys() (通过 keys 迭 代) myDict.itervalues() (通过 values 迭代) myDicit.iteritems() (通过 key/value 对 来迭代). 注意： in 操作符也可以用于检查字典的 key 是否存在 ，之前的布尔表达式 myDict.has_key(anyKey) 可以被简写为 anyKey in myDict 。 文件文件对象生成的迭代器会自动调用 readline() 方法. 这样，循环就可以访问文本文件的所有 行。 程序员可以使用 更简单的 for eachLine in myFile 替换 for eachLine in myFile.readlines() 可变对象和迭代器记住，在迭代可变对象的时候修改它们并不是个好主意。 一个流行的例子就是循环列表的时候删除满足(或不满足)特定条件的项： 123for eachURL in allURLs: if not eachURL.startswith('http://'):a llURLs.remove(eachURL) # YIKES!! 一个序列的迭代器只是记录你 当前到达第多少个元素，所以如果你在迭代时改变了元素，更新会立即反映到你所迭代的条目上。 在迭代字典的 key 时，你绝对不能改变这个字典。使用字典的 keys() 方法是可以的，因为 keys() 返回一个独立于字典的列表。 而迭代器是与实际对象绑定在一起的， 它将不会继续执行下去 12345678&gt;&gt;&gt; myDict = &#123;'a': 1, 'b': 2, 'c': 3, 'd': 4&#125;&gt;&gt;&gt; for eachKey in myDict:... print eachKey, myDict[eachKey]... del myDict[eachKey]... a 1Traceback (most recent call last):File "", line 1, in ?RuntimeError: dictionary changed size during iteration 推导式推导式是从一个或者多个迭代器快速简洁地创建数据结构的一种方法。 它可以将循环和条 件判断结合，从而避免语法冗长的代码。 会使用推导式有时可以说明你已经超过 Python 初 学者的水平。也就是说，使用推导式更像 Python 风格。 列表推导式语法： 1[ expression for item in iterable ] 下面的例子将通过列表推导创建一个整数列表: 123&gt;&gt;&gt; number_list = [number for number in range(1,6)]&gt;&gt;&gt; number_list[1, 2, 3, 4, 5] 在第一行中，第一个 number 变量为列表生成值，也就是说，把循环的结果放在列表 number_list 中。第二个 number 为循环变量。其中第一个 number 可以为表达式，试试下面 改编的例子: 123&gt;&gt;&gt; number_list = [number-1 for number in range(1,6)]&gt;&gt;&gt; number_list[0, 1, 2, 3, 4] 列表推导把循环放在方括号内部。这种例子和之前碰到的不大一样，但却是更为常见的方 式。 同样，列表推导也可以像下面的例子加上条件表达式: 1[expression for item in iterable if condition] 现在，通过推导创建一个在1到5之间的偶数列表(当number % 2为真时，代表奇数;为假时，代表偶数): 123&gt;&gt;&gt; a_list = [number for number in range(1,6) if number % 2 == 1]&gt;&gt;&gt; a_list[1, 3, 5] 于是，上面的推导要比之前传统的方法更简洁: 1234567&gt;&gt;&gt; a_list = []&gt;&gt;&gt; for number in range(1,6):... if number % 2 == 1:... a_list.append(number)...&gt;&gt;&gt; a_list[1, 3, 5] 最后，正如存在很多嵌套循环一样，在对应的推导中也会有多个 for … 语句。我们先来看一个简单的嵌套循环的例子: 12345&gt;&gt;&gt; rows = range(1,4)&gt;&gt;&gt; cols = range(1,3)&gt;&gt;&gt; for row in rows:... for col in cols:... print(row, col) 下面使用一次推导，将结果赋值给变量 cells，使它成为元组 (row,col): 12345&gt;&gt;&gt; rows = range(1,4)&gt;&gt;&gt; cols = range(1,3)&gt;&gt;&gt; cells = [(row, col) for row in rows for col in cols]&gt;&gt;&gt; for cell in cells:... print(cell) 其中，在列表推导中 for row … 和 for col … 都可以有自己单独的 if 条件判断。 字典推导式除了列表，字典也有自己的推导式。最简单的例子就像: 1&#123; key_expression : value_expression for expression in iterable &#125; 类似于列表推导，字典推导也有 if 条件判断以及多个 for 循环迭代语句: 1234&gt;&gt;&gt; word = 'letters'&gt;&gt;&gt; letter_counts = &#123;letter: word.count(letter) for letter in word&#125; &gt;&gt;&gt; letter_counts&#123;'l': 1, 'e': 2, 't': 2, 'r': 1, 's': 1&#125; 程序中，对字符串 ‘letters’ 中出现的字母进行循环，计算出每个字母出现的次数。 对于 程序执行来说，两次调用 word.count(letter) 浪费时间，因为字符串中 t 和 e 都出现了两 次，第一次调用word.count() 时已经计算得到相应的值。下面的例子会解决这个小问题， 更符合 Python 风格: 1234&gt;&gt;&gt; word = 'letters'&gt;&gt;&gt; letter_counts = &#123;letter: word.count(letter) for letter in set(word)&#125; &gt;&gt;&gt; letter_counts&#123;'t': 2, 'l': 1, 'e': 2, 'r': 1, 's': 1&#125; 字典键的顺序和之前的例子是不同的，因为是对 set(word)集合进行迭代的，而前面的例 子是对 word 字符串迭代。 集合推导式集合也不例外，同样有推导式。最简单的版本和之前的列表、字典推导类似: 1&#123;expression for expression in iterable &#125; 最长的版本(if tests, multiple for clauses)对于集合而言也是可行的: 123&gt;&gt;&gt; a_set = &#123;number for number in range(1,6) if number % 3 == 1&#125;&gt;&gt;&gt; a_set&#123;1, 4&#125; 生成器推导式元组是没有推导式的。你可能认为将列表推导式中的方括号变成圆括号就可以定义元组推导式，就像下面的表达式一样: 1&gt;&gt;&gt; number_thing = (number for number in range(1, 6)) 其实，圆括号之间的是生成器推导式，它返回的是一个生成器对象: 12&gt;&gt;&gt; type(number_thing)&lt;class 'generotor'&gt; 生成器是将数据传给迭代器的一种方式。 你可以直接对生成器对象进行迭代 12345678&gt;&gt;&gt; for number in number_thing:... print(number)...12 3 4 5 或者，通过对一个生成器的推导式调用 list() 函数，使它类似于列表推导式: 123&gt;&gt;&gt; number_list = list(number_thing)&gt;&gt;&gt; number_list[1, 2, 3, 4, 5] 一个生成器只能运行一次。列表、集合、字符串和字典都存储在内存中，但 是生成器仅在运行中产生值，不会被存下来，所以不能重新使用或者备份一 个生成器。 如果想再一次迭代此生成器，会发现它被擦除了: 123&gt;&gt;&gt; try_again = list(number_thing)&gt;&gt;&gt; try_again[]]]></content>
      <categories>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Python条件和循环]]></title>
    <url>%2F2018%2F02%2F09%2FPython%E6%9D%A1%E4%BB%B6%E5%92%8C%E5%BE%AA%E7%8E%AF%2F</url>
    <content type="text"><![CDATA[if 语句if 语句的语法如下: 12if expression: expr_true_suite if 语句的 expr_true_suite 代码块只有在条件表达式的结果的布尔值为真时才执行 多重条件表达式单个 if 语句可以通过使用布尔操作符and , or 和 not 实现多重判断条件或是否定判断条件. 123if not warn and (system_load &gt;= 10): print "WARNING: losing resources" warn += 1 单一语句的代码块如果一个复合语句(例如 if 子句, while 或 for 循环)的代码块仅仅包含一行代码, 那么它可 以和前面的语句写在同一行上: 1if make_hard_copy: send_data_to_printer() 为了代码可读性，并不推荐这么做 else 语句如果 if 语句的条件表达式的结果布尔值为假, 那么程序将执行 else 语句后的代码 1234if expression: expr_true_suiteelse: expr_false_suite elif (即 else-if )语句12345678if expression1: expr1_true_suiteelif expression2: expr2_true_suiteelif expressionN: exprN_true_suiteelse: none_of_the_above_suite 使用 if-elif 语句模拟switch/case 12345678if user.cmd == 'create': action = "create item"elif user.cmd == 'delete': action = 'delete item'elif user.cmd == 'update': action = 'update item'else: action = 'invalid choice... try again!' 上面的语句完全可以满足我们的需要, 不过我们还可以用序列和成员关系操作符来简化它: 1234if user.cmd in ('create', 'delete', 'update'): action = '%s item' % user.cmdelse: action = 'invalid choice... try again!' 另外我们可以用 Python 字典给出更加优雅的解决方案 12345msgs = &#123;'create': 'create item', 'delete': 'delete item', 'update': 'update item'&#125;default = 'invalid choice... try again!'action = msgs.get(user.cmd, default) 使用映射对象(比如字典)的一个最大好处就是它的搜索操作比类似 if-elif-else 语句或是 for 循环这样的序列查询要快很多. 三元操作符1X if C else Y 如果 C 为真，那么 X，否则 Y while 语句 while 中的代码块会一直循环执行, 直到循环条件不再为真 12while expression: suite_to_repeat while 循环的 suite_to_repeat 子句会一直循环执行， 直到 expression 值为布尔假。这种 类型的循环机制常常用在计数循环中 1234count = 0while (count &lt; 9): print 'the index is:', count count += 1 for 语句Python 提供给我们的另一个循环机制就是 for 语句. 它提供了 Python 中最强大的循环结构. 它可以遍历序列成员，可以用在 列表解析 和 生成器表达式中, 它会自动地调用迭代器的 next() 方法，捕获 StopIteration 异常并结束循环(所有这一切都是在内部发生的). 一般语法for 循环会访问一个可迭代对象(例如序列或是迭代器)中的所有元素, 并在所有条目都处理过 后结束循环. 它的语法如下: 12for iter_var in iterable: suite_to_repeat 用于序列类型当迭代字符串时, 迭代变量只会包含一个字符(长度为 1 的字符串). 但这并不常用。 1234567&gt;&gt;&gt; for eachLetter in 'Names':... print 'current letter:', eachLetter ...current letter: Ncurrent letter: acurrent letter: mcurrent letter: ecurrent letter: s 迭代序列有三种基本方法: 通过序列项迭代 12345678&gt;&gt;&gt; nameList = ['Walter', "Nicole", 'Steven', 'Henry'] &gt;&gt;&gt; for eachName in nameList:... print eachName, "Lim"...Walter LimNicole LimSteven LimHenry Lim 通过序列索引迭代 123456789&gt;&gt;&gt; nameList = ['Cathy', "Terry", 'Joe', 'Heather', 'Lucy']&gt;&gt;&gt; for nameIndex in range(len(nameList)):... print "Liu,", nameList[nameIndex]...Liu, CathyLiu, TerryLiu, JoeLiu, HeatherLiu, Lucy 我们没有迭代元素，而是通过列表的索引迭代 这里我们使用了内建的 len() 函数获得序列长度, 使用 range() 函数创建了要迭代的序列. 1234&gt;&gt;&gt; len(nameList)5&gt;&gt;&gt; range(len(nameList))[0, 1, 2, 3, 4] 如果你对性能有所了解的话，那么毫无疑问你会意识到 直接迭代序列要比通过索引迭代快. 使用项和索引迭代 两全其美的办法是使用内建的 enumerate() 函数 1234567891011&gt;&gt;&gt; nameList = ['Donn', 'Shirley', 'Ben', 'Janice', ... 'David', 'Yen', 'Wendy']&gt;&gt;&gt; for i, eachLee in enumerate(nameList):... print "%d %s Lee" % (i+1, eachLee)...1 Donn Lee2 Shirley Lee3 Ben Lee4 Janice Lee5 David Lee6 Yen Lee7 Wendy Lee 用于字典类型对一个字典(或者字典的 keys() 函数)进行迭代将返回字典中的键。 1234567&gt;&gt;&gt; accusation = &#123;'room': 'ballroom', 'weapon': 'lead pipe', 'person': 'Col. Mustard'&#125;&gt;&gt;&gt; for card in accusation: # 或者是for card in accusation.keys():... print(card)...roomweaponperson 如果想对字典的值进行迭代，可以使用字典的 values() 函数: 12&gt;&gt;&gt; for value in accusation.values():... print(value) 为了以元组的形式返回键值对，可以使用字典的 items() 函数: 123456&gt;&gt;&gt; for item in accusation.items(): ... print(item)...('room', 'ballroom')('weapon', 'lead pipe') ('person', 'Col. Mustard') 对于调用函数items() 返回的每一 个元组，将第一个返回值(键)赋给 card，第二个返回值(值)赋给 contents: 12&gt;&gt;&gt; for card, contents in accusation.items():... print('Card', card, 'has the contents', contents) 用于迭代器类型用 for 循环访问迭代器和访问序列的方法差不多。 唯一的区别就是 for 语句会为你做一些额 外的事情。 迭代器并不代表循环条目的集合。 迭代器对象有一个 next() 方法，调用后返回下一个条目。所有条目迭代完后， 迭代器引发一 个 StopIteration 异常告诉程序循环结束。for 语句在内部调用 next() 并捕获异常。 使用迭代器做 for 循环的代码与使用序列条目几乎完全相同。事实上在大多情况下，你无法 分辨出你迭代的是一个序列还是迭代器，因此，这就是为什么我们在说要遍历一个迭代器时，实际 上可能我们指的是要遍历一个序列，迭代器，或是一个支持迭代的对象(它有 next()方法)。 range() 内建函数range() 的完整语法完整语法要求提供两个或三个整数参数 1range(start, end, step =1) range() 会返回一个包含所有 k 的列表，这里 start &lt;= k &lt; end，从 start 到 end ， k 每次递增 step。 step 不可以为零，否则将发生错误。 12&gt;&gt;&gt; range(2, 19, 3)[2, 5, 8, 11, 14, 17] 如果只给定两个参数，而省略 step， step 就使用默认值 1 12&gt;&gt;&gt; range(3, 7)[3, 4, 5, 6] range()的参 数与 C语言 的 for 循环变量有着直接的关系 123for (eachVal = 2; eachVal &lt; 19; eachVal += 3) &#123; printf("value is: %d\n", eachVal);&#125; 虽然看起来像是一个条件循环(检查 eachVal&lt; 19 )， 但实际上是 range() 先用我们指定的条 件生成一个列表， 然后把列表用于这个 for 语句 range() 简略语法range() 还有种简略的语法格式: 1range(end) start 默认为 0 ，step 默认为 1 ，然后range()返回从 0 到 end 的数列 12&gt;&gt;&gt; range(5)[0, 1, 2, 3, 4] xrange() 内建函数xrange()类似 range()，不过当你有一个很大的范围列表时，xrange() 可能更为适合， 因为 它不会在内存里创建列表的完整拷贝。 它只被用在 for 循环中， 在 for 循环外使用它没有意义。 同样地，你可以想到, 它的性能远高出 range()， 因为它不生成整个列表。 python3 中已经取消了 range()，同时将 xrange() 重新命名成 range()，如果希望生成原来的列表形式的 range，只要用list(range(…))就可以了。 break 语句break 语句可以结束当前循环然后跳转到下条语句， 常用在当某个外部条件被触发(一般通过 if 语句检查)，需要立即从循环中退出时。 break 语句可 以用在 while 和 for 循环中. continue 语句一些初学者有这样 的一个误解：continue 语句”立即启动循环的下一次迭代”. 实际上，当遇到 continue 语句时， 程 序会终止当前循环，并忽略剩余的语句，然后回到循环的顶端. 在开始下一次迭代前，如果是条件循 环，我们将验证条件表达式。如果是迭代循环，我们将验证是否还有元素可以迭代。只有在验证成功 的情况下， 我们才会开始下一次迭代。 它可以被 用在 while 和 for 循环里。 while 循环是条件性的， 而 for 循环是迭代的。 123456789101112131415valid = Falsecount = 3while count &gt; 0: input = raw_input("enter password") # check for valid passwd for eachPasswd in passwdList: if input == eachPasswd: valid = True break if not valid: # (or valid == 0) print "invalid input" count -= 1 continue else: break pass 语句Python 没有使用传统的大括号来标 记代码块，有时，有些地方在语法上要求要有代码，而 Python 中没有对应的空大括号或是分号;来表示 “不做任何事”， 如果你在需要子语句块的地方不写任何语句， 解释器会提示你 语法错误。 因此， Python 提供了 pass语句， 它不做任何事情 pass 同样也可作为开发中的小技巧，标记你后来要完成的 代码，例如这样: 12def foo_func(): pass 1234if user_choice == 'do_calc': pass else: pass while 和 for 中的 else 语句在 Python 中， 你可以在 while 和 for 循环中使用 else 语句。else 子句只在循环完成后执行，也就是说 break 语句也会跳过 else 块。 当你想确认之前的 for 循环是否正常跑完，增加 else 判断是有用的。下面的例子中，for循环打印输出奶酪的名称，并且如果任一奶酪在商店中找到则跳出循环: 12345678&gt;&gt;&gt; cheeses = []&gt;&gt;&gt; for cheese in cheeses:... print('This shop has some lovely', cheese)... break... else:... print('This is not much of a cheese shop, is it?')...This is not much of a cheese shop, is it? for 循环用来遍历查找，如果没有找到则调用执行 else。 同样在没有 else 的情况下，为了达到相同的作用，可以声明某个变量 指出在 for 循环中是否找到，看下面的例子: 1234567891011&gt;&gt;&gt; cheeses = []&gt;&gt;&gt; found_one = False&gt;&gt;&gt; for cheese in cheeses:... found_one = True... print('This shop has some lovely', cheese)... break...&gt;&gt;&gt; if not found_one:... print('This is not much of a cheese shop, is it?') ...This is not much of a cheese shop, is it? 使用zip()并行迭代在使用迭代时，有一个非常方便的技巧:通过 zip() 函数对多个序列进行并行迭代: 12345678910&gt;&gt;&gt; days = ['Monday', 'Tuesday', 'Wednesday']&gt;&gt;&gt; fruits = ['banana', 'orange', 'peach']&gt;&gt;&gt; drinks = ['coffee', 'tea', 'beer']&gt;&gt;&gt; desserts = ['tiramisu', 'ice cream', 'pie', 'pudding']&gt;&gt;&gt; for day, fruit, drink, dessert in zip(days, fruits, drinks, desserts): ... print(day, ": drink", drink, "- eat", fruit, "- enjoy", dessert) ...Monday : drink coffee - eat banana - enjoy tiramisuTuesday : drink tea - eat orange - enjoy ice creamWednesday : drink beer - eat peach - enjoy pie zip() 函数在最短序列“用完”时就会停止。 dict() 函数会将两项序列，比如元组、列表、字符串，创建成一个字典。 zip() 函数可以遍历多个序列，在具有相同位移的项之间创建元组。 下面创建英语单 词和法语单词之间的对应关系的两个元组: 12&gt;&gt;&gt; english = 'Monday', 'Tuesday', 'Wednesday' &gt;&gt;&gt; french = 'Lundi', 'Mardi', 'Mercredi' 现在使用 zip() 函数配对两个元组。函数的返回值既不是元组也不是列表，而是一个整合在一起的可迭代变量: 12&gt;&gt;&gt; list( zip(english, french) )[('Monday', 'Lundi'), ('Tuesday', 'Mardi'), ('Wednesday', 'Mercredi')] 配合 dict() 函数和 zip() 函数的返回值就可以得到一本微型的英法词典: 12&gt;&gt;&gt; dict( zip(english, french) )&#123;'Monday': 'Lundi', 'Tuesday': 'Mardi', 'Wednesday': 'Mercredi'&#125;]]></content>
      <categories>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Python 对象]]></title>
    <url>%2F2018%2F02%2F08%2FPython-%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[Python 对象Python 使用对象模型来存储数据。构造任何类型的值都是一个对象。 所有的 Python 对像都拥有三个特性：身份，类型和值。 身份 每一个对象都有一个唯一的身份标识自己，任何对象的身份可以使用内建函数id()来得到。这个值可以被认为是该对象的内存地址。 类型 对象的类型决定了该对象可以保存什么类型的值，可以进行什么样的操作，以及遵循什么样的规则。您可以用内建函数 type()查看 Python 对象的类型。因为在 Python 中类型也是对象，所以type()返回的是对象而不是简单的 字符串。 值 对象表示的数据项 上面三个特性在对象创建的时候就被赋值，除了值之外，其它两个特性都是只读的。对于 新风格的类型和类, 对象的类型也是可以改变的。 类型对象和type类型对象虽然看上去把类型本身也当成对象有点特别，我们 还是要在这里提一提。你一定还记得，对象的一系列固有行为和特性(比如支持哪些运算，具 有哪些方法)必须事先定义好。从这个角度看，类型正是保存这些信息的最佳位置。描述一种 类型所需要的信息不可能用一个字符串来搞定，所以类型不能是一个简单的字符串，这些信息 不能也不应该和数据保存在一起， 所以我们将类型定义成对象。 下面我们来正式介绍内建函数type()。通过调用 type()函数你能够得到特定对象的类型 信息: 12&gt;&gt;&gt; type(42)&lt;type &apos;int&apos;&gt; 您看到的&lt;type &#39;int&#39;&gt;实际上是一个类型对象，碰巧它输出了一个字符串来告诉你 它是个int 型对象。 那么类型对象的类型是什么? 12&gt;&gt;&gt; type(type(42))&lt;type &apos;type&apos;&gt; 没错，所有类型对象的类型都是 type，它也是所有 Python 类型的根和所有 Python 标准类 的默认元类(metaclass)。 None，Python 的 Null 对象Python有一个特殊的类型，被称作 Null 对象或者 NoneType，它只有一个值，那就是 None。 它不支持任何运算也没有任何内建方法。如果非常熟悉 C 语言，和 None 类型最接近的 C 类型就 是 void，None 类型的值和 C 的 NULL 值非常相似(其他类似的对象和值包括 Perl 的 undef 和 Java 的 void 类型与 null 值)。 None 没有什么有用的属性，它的布尔值总是 False。 对象的布尔值所有标准对象均可用于布尔测试，同类型的对象之间可以比较大小。 每个对象天生具有布 尔 True 或False 值。空对象、值为零的任何数字或者 Null 对象 None 的布尔值都是 False。 下列对象的布尔值是 False。 None False (布尔类型) 所有的值为零的数 0 (整型) 0.0 (浮点型) 0L (长整型) 0.0+0.0j (复数) &quot;&quot; (空字符串) [] (空列表) () (空元组) {} (空字典) set()(空集合) 值不是上面列出来的任何值的对象的布尔值都是 True，例如 non-empty、non-zero 等等。用户创建的类实例如果定义了 nonzero(__nonzero__())或length(__len__())且值为 0，那 么它们的布尔值就是False。 标准类型运算符对象值的比较比较运算符用来判断同类型对象是否相等，所有的内建类型均支持比较运算，比较运算返 回布尔值 True 或 False。 12345678910111213141516&gt;&gt;&gt; 2 == 2True&gt;&gt;&gt; 2.46 &lt;= 8.33True&gt;&gt;&gt; 5+4j &gt;= 2-3jTrue&gt;&gt;&gt; 'abc' == 'xyz'False&gt;&gt;&gt; 'abc' &gt; 'xyz'False&gt;&gt;&gt; 'abc' &lt; 'xyz'True&gt;&gt;&gt; [3, 'abc'] == ['abc', 3]False&gt;&gt;&gt; [3, 'abc'] == [3, 'abc']True 不同于很多其它语言，多个比较操作可以在同一行上进行，求值顺序为从左到右。 123456&gt;&gt;&gt; 3 &lt; 4 &lt; 7 #sameas(3&lt;4)and(4&lt;7) True&gt;&gt;&gt; 4 &gt; 3 == 3 #sameas(4&gt;3)and(3==3) True&gt;&gt;&gt; 4 &lt; 3 &lt; 5 != 2 &lt; 7False 其实这个表达式本质上是由 多个隐式的 and 连接起来的多个表达式。 12&gt;&gt;&gt; 3 &lt; 4 &lt; 7 #sameas"( 3 &lt; 4 ) and ( 4 &lt; 7 )"True 我们会注意到比较操作是针对对象的值进行的，也就是说比较的是对象的数值而不是对象 本身。 对象身份比较作为对值比较的补充，Python 也支持对象本身的比较。对象可以被赋值到另一个变量(通 过引用)。因为每个变量都指向同一个(共享的)数据对象，只要任何一个引用发生改变，该对 象的其它引用也会随之改变。 为了方便大家理解，最好先别考虑变量的值，而是将变量名看作对象的一个链接。 Python 提供了is 和 is not 运算符来测试两个变量是否指向同一个对象。象下面这样执行一个测试 1a is b 这个表达式等价于下面的表达式 1id(a) == id(b) 标准类型对象身份比较运算符： 运算符 功能 obj1 is obj2 obj1 和 obj2 是同一个对象 obj1 is not obj2 obj1 和 obj2 不是同一个对象 整型和字符串缓存在上面的例子中，您会注意到我们使用的是浮点数而不是整数。为什么这样? 整数对象和 字符串对象是不可变对象，所以Python会很高效的缓存它们。这会造成我们认为Python应该创建新对象时，它却没有创建新对象的假象。看下面的例子: 1234567891011121314&gt;&gt;&gt; a = 1&gt;&gt;&gt; id(a)8402824&gt;&gt;&gt; b = 1&gt;&gt;&gt; id(b)8402824&gt;&gt;&gt;&gt;&gt;&gt; c = 1.0&gt;&gt;&gt; id(c)8651220&gt;&gt;&gt; d = 1.0&gt;&gt;&gt; id(d)8651204 在上面的例子中，a 和 b 指向了相同的整数对象，但是 c 和 d 并没有指向相同的浮点数 对象。 如果我们是纯粹主义者，我们会希望 a 与 b 能和 c 与 d 一样，因为我们本意就是为 了创建两个整数对象，而不是像 b = a 这样的结果。 Python 仅缓存简单整数，因为它认为在 Python 应用程序中这些小整数会经常被用到。 Python 缓存的整数范围是(-1, 100)，不过这个范围是会改变的，所 以请不要在你的应用程序使用这个特性。Python 2.3 中决定，在预定义缓存字符串表之外的字符串，如果不再有任何引用指向它， 那这个字符串将不会被缓存。也就是说， 被缓存的字符串将不会象以前那样永生不灭，对象回 收器一样可以回收不再被使用的字符串。 标准类型内建函数Python 提供了一些内建函数用于这些基本对象类型：cmp(), repr(), str(), type(), 和等同于 repr()函数的单反引号 （``）运算符。 标准类型内建函数： cmp(obj1, obj2)：比较 obj1 和 obj2, 根据比较结果返回整数 i: 123i &lt; 0 if obj1 &lt; obj2i &gt; 0 if obj1 &gt; obj2i == 0 if obj1 == obj2 repr(obj) 或 `obj`：返回一个对象的字符串表示 str(obj)：返回对象适合可读性好的字符串表示 type(obj)：到一个对象的类型，并返回相应的 type 对象 type()在 Python2.2 以前，type() 是内建函数。不过从那时起， 它变成了一个“工厂函数”。后面部分我们会讨论工厂函数， 现在你仍然可以将type()仅仅当成一个内建函数来看。 type() 的用法如下: type(object) type() 接受一个对象做为参数，并返回它的类型。它的返回值是一个type类型对象。 12345678&gt;&gt;&gt; type(4) # int type&lt;type 'int'&gt;&gt;&gt;&gt;&gt;&gt;&gt; type('Hello World!') # string type&lt;type 'string'&gt;&gt;&gt;&gt;&gt;&gt;&gt; type(type(4)) # type type&lt;type 'type'&gt; 在上面的例子里， 我们通过内建函数 type() 得到了一个整数和一个字符串的类型；为了 确认一下类型本身也是类型， 我们对 type()的返回值再次调用 type()。 注意type()有趣的 输出， 它看上去不象一个典型的 Python 数据类型， 比如一个整数或一个字符串，一些东西被 一个大于号和一个小号包裹着。这种语法是为了告诉你它是一个对象。每个对象都可以实现一 个可打印的字符串表示。不过并不总是这样， 对那些不容易显示的对象来说， Python 会以一 个相对标准的格式表示这个对象，格式通常是这种形式：&lt;object_something_or_another&gt;，以 这种形式显示的对象通常会提供对象类别，对象 id 或位置, 或者其它合适的信息。 cmp()内建函数 cmp()用于比较两个对象 obj1 和 obj2， 如果 obj1 小于 obj2，则返回一个负整 数， 如果 obj1 大于 obj2 则返回一个正整数， 如果 obj1 等于 obj2， 则返回 0。 它的行为非常 类似于 C 语言的 strcmp()函数。比较是在对象之间进行的，不管是标准类型对象还是用户自定 义对象。如果是用户自定义对象，cmp()会调用该类的特殊方法__cmp__()。 下面是几个使用 cmp()内建函数的对数值和字符串对象进行比较的例子。 1234567891011121314151617&gt;&gt;&gt; a, b = -4, 12&gt;&gt;&gt; cmp(a,b)-1&gt;&gt;&gt; cmp(b,a)1&gt;&gt;&gt; b = -4&gt;&gt;&gt; cmp(a,b)0&gt;&gt;&gt;&gt;&gt;&gt; a, b = 'abc', 'xyz'&gt;&gt;&gt; cmp(a,b)-23&gt;&gt;&gt; cmp(b,a)23&gt;&gt;&gt; b = 'abc'&gt;&gt;&gt; cmp(a,b)0 str()和repr() (及 `` 运算符)内建函数str() 和repr() 或反引号运算符(``) 可以方便的以字符串的方式获取对象的 内容、类型、数值属性等信息。 str()函数得到的字符串可读性好， 而 repr()函数得到的字符串通常可以用来重新获得该对象，通常情况下 obj == eval(repr(obj))这个等式是成立的。 这两个函数接受一个对象做为其参数， 返回适当的字符串。 1234567891011121314151617&gt;&gt;&gt; str(4.53-2j)'(4.53-2j)'&gt;&gt;&gt;&gt;&gt;&gt; str(1)'1'&gt;&gt;&gt;&gt;&gt;&gt; str(2e10)'20000000000.0'&gt;&gt;&gt;&gt;&gt;&gt; str([0, 5, 9, 9])'[0, 5, 9, 9]'&gt;&gt;&gt;&gt;&gt;&gt; repr([0, 5, 9, 9])'[0, 5, 9, 9]'&gt;&gt;&gt;&gt;&gt;&gt; `[0, 5, 9, 9]`'[0, 5, 9, 9]' 尽管 str()，repr()和``运算在特性和功能方面都非常相似， 事实上repr() 和 `` 做的 是完全一样的事情，它们返回的是一个对象的“官方”字符串表示， 也就是说绝大多数情况下 可以通过求值运算(使用 eval()内建函数)重新得到该对象，但 str()则有所不同。str() 致力 于生成一个对象的可读性好的字符串表示，它的返回结果通常无法用于eval()求值， 但很适 合用于 print 语句输出。需要再次提醒一下的是， 并不是所有repr()返回的字符串都能够用eval()内建函数得到原来的对象: 1234&gt;&gt;&gt; eval(`type(type))`)File "&lt;stdin&gt;", line 1 eval(`type(type))`) ^ SyntaxError: invalid syntax 也就是说 repr()输出对 Python 比较友好， 而 str()的输出对人比较友好。 事实上 Python 社区目前已经不鼓励继续使用``运算符。 type() 和isinstance()未完，待续…]]></content>
      <categories>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Python 基础]]></title>
    <url>%2F2018%2F02%2F08%2FPython-%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[语句和语法注释#和很多 Unix 脚本类似，在 Python 中使用# 字 符标记注释，从# 开始到当前行结束的部分都是注释。 1# one comment 有一种叫做文档字符串的特别注释。你可以在模块、类或者函数的起始添加一个字符串，起到在线文档的功能。 123def foo(): "This is a doc string." return True 与普通注释不同，文档字符串可以在运行时访问，也可以用来自动生成文档。 可以通过__doc__特别变量，动态获得文档字串。 在模块，类 声明，或函数声明中第一个没有赋值的字符串可以用属性 obj.__doc__来进行访问，其中 obj 是一个模块，类，或函数的名字。这在运行时刻也可以运行。 使用\连接Python 语句，一般使用换行分隔，也就是说一行一个语句。一行过长的语句可以使用反斜 杠\ 分解成几行， 1234# check conditionsif (weather_is_hot == 1) and \ (shark_warnings == 0): send_goto_beach_mesg_to_pager() 有两种例外情况一个语句不使用反斜线也可以跨行。 在使用闭合操作符时，单一语句可以 跨多行，例如:在含有小括号、中括号、花括号时可以多行书写。 另外就是三引号包括下的字符串也可以跨行书写。如下例: 12345678# display a string with triple quotesprint'''hi there, this is a long message for youthat goes over multiple lines... you will findout soon that triple quotes in Python allowsthis kind of fun! it is like a day on the beach!'''# set some variablesgo_surf, get_a_tan_while, boat_size, toll_money = (1,'windsurfing', 40.0, -2.00) 如果要在使用反斜线换行和使用括号元素换行作一个选择，我们推荐使用括号，这样可读 性会更好。 多个语句构成代码组:缩进相同的一组语句构成一个代码块，我们称之代码组。像 if、while、def 和 class 这样 的复合语句，首行以关键字开始，以冒号:结束，该行之后的一行或多行代码构成代码组。 我们将首行及后面的代码组称为一个子句(clause)。 代码组由不同的缩进分隔我们在上面曾提到，Python 使用缩进来分隔代码组。代码的层次关系是通过同样 深度的空格或制表符缩进体现的。同一代码组的代码行必须严格左对齐(左边有同样多的空格 或同样多的制表符)，如果不严格遵守这个规则，同一组的代码就可能被当成另一个组，甚至 会导致语法错误。 缩进四个空格宽度，避免使用制表符 需要说明一点，不同 的文本编辑器中制表符代表的空白宽度不一，如果你的代码要跨平台应用，或者会被不同的编 辑器读写，建议你不要使用制表符。 同一行书写多个语句;分号;允许你将多个语句写在同一行上，语句之间用分号隔开，而这些语句也不能在这 行开始一个新的代码块。这里有一个例子: 1import sys; x = 'foo'; sys.stdout.write(x + '\n') 必须指出一点， 同一行上书写多个语句会大大降低代码的可读性 Python文件以模块的形式组织每一个 .py文件都可以被当成是一个模块。 模块里 的代码可以是一段直接执行的脚本，也可以是一堆类似库函数的代码，从而可以被别的模块导 入(import)调用。 变量赋值赋值运算符=Python 语言中， 等号=是主要的赋值运算符。 1anInt = -12 注意，赋值并不是直接将一个值赋给一个变量， 尽管你可能根据其它语言编程经验认为应 该如此。 在 Python 语言中，对象是通过引用传递的。在赋值时，不管这个对象是新创建的，还 是一个已经存在的，都是将该对象的引用(并不是值)赋值给变量。 Python 的赋值语句不会返回值。类似下面的语句在 Python 中是 非法的: 12345&gt;&gt;&gt; x = 1&gt;&gt;&gt; y = (x = x + 1) # assignments not expressions! File "&lt;stdin&gt;", line 1y = (x = x + 1)^SyntaxError: invalid syntax 增量赋值等号可以和一个算术运算符组合在一起， 将计算结果重新赋值给 左边的变量。这被称为增量赋值： 类似下面这样的语句: 1x = x + 1 可以被写成： 1x += 1 增量赋值相对普通赋值不仅仅是写法上的改变，最有意义的变化是第一个对象(我们例子 中的 A)仅被处理一次。可变对象会被就地修改(无修拷贝引用)， 不可变对象则和 A = A +B 的结果一样(分配一个新对象)，我们前面提到过，有一个例外就是 A 仅被求值一次。 Python 不支持类似 x++ 或 –x 这样的前置/后置自增/自减运算。 多重赋值1234567&gt;&gt;&gt; x = y = z = 1&gt;&gt;&gt; x1&gt;&gt;&gt; y1 &gt;&gt;&gt; z 1 在上面的例子中，一个值为 1 的整数对象被创建，该对象的同一个引用被赋值给 x、y 和 z 。也就是将一个对象赋给了多个变量。当然，在 Python 当中，将多个对象赋给多个变量也是 可以的。 多元赋值另一种将多个变量同时赋值的方法我们称为多元赋值(multuple)。等号两边的对象 都是元组(元组是一种 Python 基本数据类型)。 1234567&gt;&gt;&gt; x, y, z = 1, 2, 'a string'&gt;&gt;&gt; x1&gt;&gt;&gt; y2&gt;&gt;&gt; z'a string' 在上面的例子里， 两个整数对象(值分别为 1 和 2)及一个字符串对象， 被分别赋值给 x, y 和 z。通常元组需要用圆括号(小括号)括起来，尽管它们是可选的。 我们建议总是加上 圆括号以使得你的代码有更高的可读性。 1&gt;&gt;&gt; (x, y, z) = (1, 2, 'a string') 在 Python 中交换两个变量的值 12&gt;&gt;&gt; x, y = 1, 2&gt;&gt;&gt; x, y = y, x 标识符标识符是电脑语言中允许作为名字的有效字符串集合。 其中，有一部分是关键字，构成语 言的标识符。这样的标识符是不能做它用的标识符的，否则会引起语法错误(SyntaxError 异 常)。 合法的 Python 标识符 第一个字符必须是字母或下划线_； 剩下的字符可以是字母和数字或下划线； 大小写敏感； 不能使用以下保留的关键字作为变量名： 1['False', 'None', 'True', 'and', 'as', 'assert', 'break', 'class', 'continue', 'def', 'del', 'elif', 'else', 'except', 'finally', 'for', 'from', 'global', 'if', 'import', 'in', 'is', 'lambda', 'nonlocal', 'not', 'or', 'pass', 'raise', 'return', 'try', 'while', 'with', 'yield'] 查看有哪些关键字： 12&gt;&gt;&gt; import keyword&gt;&gt;&gt; keyword.kwlist 除了关键字之外，Python 还有可以在任何一级代码使用的“内建”的名字集合，这些名字 可以由解释器设置或使用。虽然 built-in 不是关键字，但是应该把它当作“系统保留字”，不 做他用。然而，有些情况要求覆盖(也就是:重定义，替换)它们。Python 不支持重载标识符， 所以任何时刻都只有一个名字绑定。 专用下划线标识符Python 用下划线作为变量前缀和后缀指定特殊变量。这里对 Python 中下划线的特殊用法做了总结： _xxx 不用from module import *导入 __xxx__系统定义名字 __xxx 类中的私有变量名 避免使用下划线作为变量名的开始 因为下划线对解释器有特殊的意义，而且是内建标识符所使用的符号，我们建议程序员避 免用下划线作为变量名的开始。一般来讲，变量名_xxx 被看作是“私有的”，在模块或类外不 可以使用。当变量是私有的时候，用_xxx 来表示变量是很好的习惯。因为变量名__xxx__对 Python 来说有特殊含义，对于普通的变量应当避免这种命名风格。 Python 风格指南The Zen of Python1&gt;&gt;&gt; import this 模块结构和布局用模块来合理组织你的 Python 代码是简单又自然的方法。你应该建立一种统一且容易阅读 的结构，并将它应用到每一个文件中去。下面就是一种非常合理的布局: 12345678910111213141516171819202122232425262728# 起始行(Unix)#!/usr/bin/env python # 模块文档"this is a test module"# 模块导入import sysimport os# 全局变量定义debug = True# 类定义class FooClass(object): "Foo class" pass# 函数定义def main(): "test function" foo = FooClass() if debug: print('ran main()')# 主程序if __name__ == '__main__': main() 起始行通常只有在类 Unix 环境下才使用起始行，有起始行就能够仅输入脚本名字来执行脚本，无 需直接调用解释器。​ 模块文档简要介绍模块的功能及重要全局变量的含义，模块外可通过 module.__doc__访问这些内 容。​ 模块导入导入当前模块的代码需要的所有模块；每个模块仅导入一次(当前模块被加载时)；函数内部的模块导入代码不会被执行， 除非该函数正在执行。​ 变量定义这里定义的变量为全局变量，本模块中的所有函数都可直接使用。从好的编程风格角度说， 除非必须，否则就要尽量使用局部变量代替全局变量，如果坚持这样做，你的代码就不但容易维护，而且还可以提高性能并节省内存。​ 类定义语句所有的类都需要在这里定义。当模块被导入时 class 语句会被执行， 类也就会被定义。类 的文档变量是 class.__doc__。​ 函数定义语句此处定义的函数可以通过 module.function()在外部被访问到，当模块被导入时 def 语句 会被执行， 函数也就都会定义好，函数的文档变量是 function.__doc__。​ 主程序无论这个模块是被别的模块导入还是作为脚本直接执行，都会执行这部分代码。通常这里 不会有太多功能性代码，而是根据执行的模式调用不同的函数。 主程序调用 main()函数主程序代码通常都和你前面看到的代码相似，检查__name__变量的值然后再执行相应的 调用。 主程序中的代码通常包括变量赋值， 类定义和函数定义，随后检查__name__来决定是否调用另一个函数(通常调用 main()函数)来完成该模块的功能。主 程序通常都是做这些事。这儿是放置测试代码的好地 方。 大部分的 Python 模块都是用于导入调用的，直接运行模块 应该调用该模块的回归测试代码。 很多项目都是一个主程序，由它导入所有需要的模块。所以请记住，绝大部分的模块创建 的目的是为了被别人调用而不是作为独立执行的脚本。我们也很可能创建一个 Python 库风格的模块，这种模块的创建目的就是为了被其他模块调用。 总之，只有一个模块，也就是包含主程 序的模块会被直接执行，或由用户通过命令行执行，或作为批处理执行， 或由 Unix cron 任务 定时执行，或通过 Web 服务器调用，或通过 GUI 执行。 时刻记住一个事实，那就是所有的模块都有能力来执行代码。最高级别的 Python 语句– 也就是说， 那些没有缩进的代码行在模块被导入时就会执行， 不管是不是真的需要执行。由 于有这样一个“特性”，比较安全的写代码的方式就是除了那些真正需要执行的代码以外， 几 乎所有的功能代码都在函数当中。 再说一遍， 通常只有主程序模块中有大量的顶级可执行代码， 所有其它被导入的模块只应该有很少的顶级执行代码，所有的功能代码都应该封装在函数或类 当中。 __name__ 指示模块应如何被加载 由于主程序代码无论模块是被导入还是被直接执行都会运行，我们必须知道模块如何决定 运行方向。一个应用程序可能需要导入另一个应用程序的一个模块，以便重用一些有用的代码 (否则就只能用拷贝粘贴那种非面向对象的愚蠢手段)。这种情况下，你只想访问那些位于其 它应用程序中的代码，而不是想运行那个应用程序。因此一个问题出现了，“Python 是否有 一种方法能在运行时检测该模块是被导入还是被直接执行呢?” 答案就是……(鼓声雷动)…..没错! name 系统变量就是正确答案。如果模块是被导入， name 的值为模块名字 如果模块是被直接执行， name 的值为 ‘main‘ 在主程序中书写测试代码优秀的程序员和软件工程师，总是会为我们的应用程序提供一组测试代码或者简单教程。 对那些仅仅为了让别的程序导入而创建的模块来说， Python 有效的简化了这个任务。这些模 块理论上永远不会被直接执行， 那么，在这个模块被直接执行时进行系统测试岂不妙哉? 设 置起来难吗? 一点儿也不。 测试代码仅当该文件被直接执行时运行， 也就是说不是被别的模块导入时。上文及核心笔 记中提到如何判断一个模块是被直接运行还是被导入。我们应该利用 __name__变量这个有利 条件。将测试代码放在一个或者叫 main(), 或者叫 test()(或者你随便取个啥名字)的函数中，如果该模块是被当成脚本运行， 就调用这个函数。 这些测试代码应该随着测试条件及测试结果的变更及时修改， 每次代码更新都应该运行这 些测试代码，以确认修改没有引发新问题。只要坚持这样做，你的代码就会足够健壮，更不用 提验证和测试新特性和更新了。 在主程序中放置测试代码是测试模块的简单快捷的手段。Python 标准库中还提供了 unittest 模块， 有时候它被称为 PyUnit, 是一个测试框架。 内存管理变量定义在 Python 中，无需显式声明变量，变量在第一次被赋值时自动声明。和其他大 多数语言一样，变量只有被创建和赋值后才能被使用。 动态类型还要注意一点，Python 中不但变量名无需事先声明，而且也无需类型声明。Python 语言中， 对象的类型和内存占用都是运行时确定的。尽管代码被编译成字节码，Python 仍然是一种解释 型语言。在创建–也就是赋值时，解释器会根据语法和右侧的操作数来决定新对象的类型。 在对象创建后，一个该对象的应用会被赋值给左侧的变量。 引用计数保持追踪内存中的对象， Python 使用了引用计数这一简单技术。也就是说 Python 内部 记录着所有使用中的对象各有多少引用。 一个内部跟踪变量，称为一个引用计数器。至于每个对象各有多少个引用， 简称引用计数。当 对象被创建时， 就创建了一个引用计数， 当这个对象不再需要时， 也就是说， 这个对象的 引用计数变为 0 时， 它被垃圾回收。(严格来说这不是 100%正确，不过现阶段你可以就这么 认为) 增加引用计数当对象被创建并(将其引用)赋值给变量时，该对象的引用计数就被设置为 1。 当同一个对象(的引用)又被赋值给其它变量时，或作为参数传递给函数， 方法或类实例 时， 或者被赋值为一个窗口对象的成员时，该对象的一个新的引用，或者称作别名，就被创建 (则该对象的引用计数自动加 1)。 总之，对象的引用计数总是会在以下情况增加： 对象被创建 1x = 3.14 或另外的别名被创建 1y = x 或被作为参数传递给函数(新的本地引用) 1foobar(x) 或成为容器对象的一个元素 1myList = [123, x, 'xyz'] 减少引用计数对象的引用被销毁时，引用计数会减小。最明显的例子就是当引用离开其作用范围时， 这种情况最经常出现在函数运行结束时，所有局部变量都被自动销毁，对象的引用计数也就随 之减少。 当变量被赋值给另外一个对象时，原对象的引用计数也会自动减 1: 123foo = 'xyz'bar = foofoo = 123 当字符串对象”xyz”被创建并赋值给 foo 时， 它的引用计数是 1. 当增加了一个别名 bar 时， 引用计数变成了 2. 不过当 foo 被重新赋值给整数对象 123 时， xyz 对象的引用计数自动减 1，又重新变成了 1. 总结一下， 一个对象的引用计数在以下情况会减少: 一个本地引用离开了其作用范围。比如 foobar()函数结束时。 对象的别名被显式的销毁。 1del y # or del x 对象的一个别名被赋值给其它的对象 1x = 123 对象被从一个窗口对象中移除 1myList.remove(x) 窗口对象本身被销毁 1del myList # or goes out-of-scope del 语句Del 语句会删除对象的一个引用，它的语法是: 1del obj1[, obj2[,... objN]] 例如，在上例中执行 del y 会产生两个结果: 从现在的名字空间中删除y x的引用计数减一 引申一步， 执行 del x 会删除该对象的最后一个引用， 也就是该对象的引用计数会减为 0， 这会导致该对象从此“无法访问”或“无法抵达”。 从此刻起， 该对象就成为垃圾回收 机制的回收对象。 注意任何追踪或调试程序会给一个对象增加一个额外的引用， 这会推迟该对象被回收的时间。 垃圾回收不再被使用的内存会被一种称为垃圾收集的机制释放。象上面说的， 虽然解释器跟踪对象 的引用计数， 但垃圾收集器负责释放内存。垃圾收集器是一块独立代码， 它用来寻找引用计 数为 0 的对象。它也负责检查那些虽然引用计数大于 0 但也应该被销毁的对象。 特定情形会导 致循环引用。 一个循环引用发生在当你有至少两个对象互相引用时， 也就是说所有的引用都消失时， 这 些引用仍然存在， 这说明只靠引用计数是不够的。Python 的垃圾收集器实际上是一个引用计 数器和一个循环垃圾收集器。 当一个对象的引用计数变为 0，解释器会暂停，释放掉这个对象 和仅有这个对象可访问(可到达)的其它对象。作为引用计数的补充， 垃圾收集器也会留心被 分配的总量很大(及未通过引用计数销毁的那些)的对象。 在这种情况下， 解释器会暂停下 来， 试图清理所有未引用的循环。]]></content>
      <categories>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Python 字典和集合]]></title>
    <url>%2F2018%2F02%2F07%2FPython-%E5%AD%97%E5%85%B8%E5%92%8C%E9%9B%86%E5%90%88%2F</url>
    <content type="text"><![CDATA[字典(dictionary)与列表类似，但其中元素的顺序无关紧要，因为它们不是通过像 0 或 1 的偏移量访问的。 取而代之，每个元素拥有与之对应的互不相同的键(key)，需要通过键 来访问元素。键通常是字符串，但它还可以是 Python 中其他任意的不可变类型:布尔型、 整型、浮点型、元组、字符串，以及其他一些在后面的内容中会见到的类型。 字典是可变 的，因此你可以增加、删除或修改其中的键值对。 使用{}创建字典用大括号{}将一系列以逗号隔开的键值对key: value包裹起来即可进行字典的创建。 最简单的字典是空字典，它不包含任何键值对: 123&gt;&gt;&gt; empty_dict = &#123;&#125;&gt;&gt;&gt; empty_dict&#123;&#125; 引用 Ambrose Bierce 的《魔鬼词典》(The Devil’s Dictionary)来创建一个字典 123456&gt;&gt;&gt; bierce = &#123;... "day": "A period of twenty-four hours, mostly misspent",... "positive": "Mistaken at the top of one's voice",... "misfortune": "The kind of fortune that never misses",... &#125; &gt;&gt;&gt; 在交互式解释器中输入字典名会打印出它所包含的所有键值对: 1234&gt;&gt;&gt; bierce&#123;'misfortune': 'The kind of fortune that never misses', 'positive': "Mistaken at the top of one's voice",'day': 'A period of twenty-four hours, mostly misspent'&#125; Python 允许在列表、元组或字典的最后一个元素后面添加逗号，这不会产生 任何问题。 此外，在括号之间输入键值对来创建字典时并不强制缩进，我这 么做只是为了增加代码的可读性。 使用dict()转换为字典可以用dict() 将包含双值子序列的序列转换成字典。(你可能会经常遇到这种子序列，例 如“Strontium，90，Carbon，14” 或 者“Vikings，20，Packers，7”， 等 等。) 每 个 子 序 列 的第一个元素作为键，第二个元素作为值。 首先，这里有一个使用 lol(a list of two-item list)创建字典的小例子: 123&gt;&gt;&gt; lol = [ ['a', 'b'], ['c', 'd'], ['e', 'f'] ] &gt;&gt;&gt; dict(lol)&#123;'c': 'd', 'a': 'b', 'e': 'f'&#125; 记住，字典中元素的顺序是无关紧要的，实际存储顺序可能取决于你添加元 素的顺序。 可以对任何包含双值子序列的序列使用 dict() 包含双值元组的列表: 123&gt;&gt;&gt; lot = [ ('a', 'b'), ('c', 'd'), ('e', 'f') ] &gt;&gt;&gt; dict(lot)&#123;'c': 'd', 'a': 'b', 'e': 'f'&#125; 包含双值列表的元组 123&gt;&gt;&gt; tol = ( ['a', 'b'], ['c', 'd'], ['e', 'f'] ) &gt;&gt;&gt; dict(tol)&#123;'c': 'd', 'a': 'b', 'e': 'f'&#125; 双字符的字符串组成的列表: 123&gt;&gt;&gt; los = [ 'ab', 'cd', 'ef' ] &gt;&gt;&gt; dict(los)&#123;'c': 'd', 'a': 'b', 'e': 'f'&#125; 双字符的字符串组成的元组: 123&gt;&gt;&gt; tos = ( 'ab', 'cd', 'ef' ) &gt;&gt;&gt; dict(tos)&#123;'c': 'd', 'a': 'b', 'e': 'f'&#125; 使用 zip() 函数能非常简单地创建上面这种双元素序列。 使用[key]添加或修改元素向字典中添加元素非常简单，只需指定该元素的键并赋予相应的值即可。 如果该元素的键 已经存在于字典中，那么该键对应的旧值会被新值取代。 如果该元素的键并未在字典中出 现，则会被加入字典。 与列表不同，你不需要担心赋值过程中 Python 会抛出越界异常。 我们来建立一个包含大多数 Monty Python 成员名字的字典，用他们的姓当作键，名当作值: 123456789&gt;&gt;&gt; pythons = &#123;... 'Chapman': 'Graham',... 'Cleese': 'John',... 'Idle': 'Eric',... 'Jones': 'Terry',... 'Palin': 'Michael',... &#125;&gt;&gt;&gt; pythons&#123;'Cleese': 'John', 'Jones': 'Terry', 'Palin': 'Michael', 'Chapman': 'Graham', 'Idle': 'Eric'&#125; 新增： 123&gt;&gt;&gt; pythons['Gilliam'] = 'Gerry'&gt;&gt;&gt; pythons&#123;'Cleese': 'John', 'Gilliam': 'Gerry', 'Palin': 'Michael', 'Chapman': 'Graham', 'Idle': 'Eric', 'Jones': 'Terry'&#125; 修改： 123&gt;&gt;&gt; pythons['Gilliam'] = 'Terry'&gt;&gt;&gt; pythons&#123;'Cleese': 'John', 'Gilliam': 'Terry', 'Palin': 'Michael', 'Chapman': 'Graham', 'Idle': 'Eric', 'Jones': 'Terry'&#125; 通过使用相同的键(‘Gilliam’)将原本的对应值 ‘Gerry’ 修改为了 ‘Terry’。 使用update()合并字典使用 update()可以将一个字典的键值对复制到另一个字典中去。 首先定义一个包含所有成员的字典 pythons: 12345678910&gt;&gt;&gt; pythons = &#123;... 'Chapman': 'Graham',... 'Cleese': 'John',... 'Gilliam': 'Terry',... 'Idle': 'Eric',... 'Jones': 'Terry',... 'Palin': 'Michael',... &#125;&gt;&gt;&gt; pythons&#123;'Cleese': 'John', 'Gilliam': 'Terry', 'Palin': 'Michael', 'Chapman': 'Graham', 'Idle': 'Eric', 'Jones': 'Terry'&#125; 接着定义一个包含其他喜剧演员的字典，命名为 others: 1&gt;&gt;&gt; others = &#123; 'Marx': 'Groucho', 'Howard': 'Moe' &#125; 现在，出现了一个糟糕的程序员，它认为 others 应该被归入 Monty Python 成员中: 123&gt;&gt;&gt; pythons.update(others)&gt;&gt;&gt; pythons&#123;'Cleese': 'John', 'Howard': 'Moe', 'Gilliam': 'Terry', 'Palin': 'Michael', 'Marx': 'Groucho', 'Chapman': 'Graham', 'Idle': 'Eric', 'Jones': 'Terry'&#125; 如果待添加的字典与待扩充的字典包含同样的键会怎样?是的，新归入字典的值会取代原 有的值: 12345&gt;&gt;&gt; first = &#123;'a': 1, 'b': 2&#125; &gt;&gt;&gt; second = &#123;'b': 'platypus'&#125; &gt;&gt;&gt; first.update(second)&gt;&gt;&gt; first&#123;'b': 'platypus', 'a': 1&#125; 使用del删除具有指定键的元素把最后添加的两个 成员清除出去: 123456&gt;&gt;&gt; del pythons['Marx']&gt;&gt;&gt; pythons&#123;'Cleese': 'John', 'Howard': 'Moe', 'Gilliam': 'Terry', 'Palin': 'Michael', 'Chapman': 'Graham', 'Idle': 'Eric', 'Jones': 'Terry'&#125;&gt;&gt;&gt; del pythons['Howard']&gt;&gt;&gt; pythons&#123;'Cleese': 'John', 'Gilliam': 'Terry', 'Palin': 'Michael', 'Chapman': 'Graham', 'Idle': 'Eric', 'Jones': 'Terry'&#125; 使用clear()删除所有元素使用clear()，或者给字典变量重新赋值一个空字典{}可以将字典中所有元素删除: 1234567&gt;&gt;&gt; pythons.clear()&gt;&gt;&gt; pythons&#123;&#125;&gt;&gt;&gt; pythons = &#123;&#125;&gt;&gt;&gt; pythons&#123;&#125; 使用in判断是否存在如果你希望判断某一个键是否存在于一个字典中，可以使用 in。 1234567&gt;&gt;&gt; pythons = &#123;'Chapman': 'Graham', 'Cleese': 'John', 'Jones': 'Terry', 'Palin': 'Michael'&#125;&gt;&gt;&gt; 'Chapman' in pythons True&gt;&gt;&gt; 'Palin' in pythons True&gt;&gt;&gt; 'Gilliam' in pythons False 使用[key]获取元素这是对字典最常进行的操作，只需指定字典名和键即可获得对应的值: 12&gt;&gt;&gt; pythons['Cleese'] 'John' 如果字典中不包含指定的键，会产生一个异常 1234&gt;&gt;&gt; pythons['Marx']Traceback (most recent call last):File "&lt;stdin&gt;", line 1, in &lt;module&gt; KeyError: 'Marx' 有两种方法可以避免这种情况的发生。第一种是在访问前通过in 测试键是否存在，就像 在上一小节看到的一样 12&gt;&gt;&gt; 'Marx' in pythons False 另一种方法是使用字典函数 get()。你需要指定字典名，键以及一个可选值。 如果键存在， 会得到与之对应的值: 12&gt;&gt;&gt; pythons.get('Cleese') 'John' 反之，若键不存在，如果你指定了可选值，那么 get() 函数将返回这个可选值: 12&gt;&gt;&gt; pythons.get('Marx', 'Not a Python')'Not a Python' 否则，会得到 None(在交互式解释器中什么也不会显示): 12&gt;&gt;&gt; pythons.get('Marx') &gt;&gt;&gt; 使用keys()获取所有键使用keys() 可以获得字典中的所有键。 12&gt;&gt;&gt; signals = &#123;'green': 'go', 'yellow': 'go faster', 'red': 'smile for the camera'&#125; &gt;&gt;&gt; signals.keys()dict_keys(['green', 'red', 'yellow']) 在 Python 2 里，keys() 会返回一个列表， 而在 Python 3 中则会返回 dict_ keys()，它是键的迭代形式。这种返回形式对于大型的字典非常有用，因为 它不需要时间和空间来创建返回的列表。 有时你需要的可能就是一个完整的 列表，但在 Python 3 中，你只能自己调用 list() 将 dict_keys 转换为列表 类型。 12&gt;&gt;&gt; list( signals.keys() ) ['green', 'red', 'yellow'] 在 Python 3 里，你同样需要手动使用 list() 将 values() 和items() 的返回 值转换为普通的 Python 列表。 使用values()获取所有值使用values() 可以获取字典中的所有值: 12&gt;&gt;&gt; list( signals.values() )['go', 'smile for the camera', 'go faster'] 使用items()获取所有键值对使用 items() 函数可以获取字典中所有的键值对: 12&gt;&gt;&gt; list( signals.items() )[('green', 'go'), ('red', 'smile for the camera'), ('yellow', 'go faster')] 每一个键值对以元组的形式返回，例如 (‘green’,’go’)。 使用=赋值，使用copy()复制与列表一样，对字典内容进行的修改会反映到所有与之相关联的变量名上: 12345&gt;&gt;&gt; signals = &#123;'green': 'go', 'yellow': 'go faster', 'red': 'smile for the camera'&#125; &gt;&gt;&gt; save_signals = signals&gt;&gt;&gt; signals['blue'] = 'confuse everyone'&gt;&gt;&gt; save_signals&#123;'blue': 'confuse everyone', 'green': 'go','red': 'smile for the camera', 'yellow': 'go faster'&#125; 若想避免这种情况，可以使用 copy() 将字典复制到一个新的字典中: 1234567&gt;&gt;&gt; signals = &#123;'green': 'go', 'yellow': 'go faster', 'red': 'smile for the camera'&#125; &gt;&gt;&gt; original_signals = signals.copy()&gt;&gt;&gt; signals['blue'] = 'confuse everyone'&gt;&gt;&gt; signals&#123;'blue': 'confuse everyone', 'green': 'go','red': 'smile for the camera', 'yellow': 'go faster'&#125;&gt;&gt;&gt; original_signals&#123;'green': 'go', 'red': 'smile for the camera', 'yellow': 'go faster'&#125; 集合集合就像舍弃了值，仅剩下键的字典一样。键与键之间也不允许重复。如果你仅仅想知道 某一个元素是否存在而不关心其他的，使用集合是个非常好的选择。如果需要为键附加其 他信息的话，建议使用字典。 使用set()创建集合你可以使用 set() 函数创建一个集合，或者用大括号将一系列以逗号隔开的值包裹起来， 123456789&gt;&gt;&gt; empty_set = set()&gt;&gt;&gt; empty_setset()&gt;&gt;&gt; even_numbers = &#123;0, 2, 4, 6, 8&#125;&gt;&gt;&gt; even_numbers&#123;0, 8, 2, 4, 6&#125;&gt;&gt;&gt; odd_numbers = &#123;1, 3, 5, 7, 9&#125;&gt;&gt;&gt; odd_numbers&#123;9, 3, 1, 5, 7&#125; 与字典的键一样，集合是无序的。 由于[] 能创建一个空列表，你可能期望 {} 也能创建空集。但事实上，{} 会 创建一个空字典，这也是为什么交互式解释器把空集输出为set() 而不是{}。 使用set()将其他类型转换为集合你可以利用已有列表、字符串、元组或字典的内容来创建集合，其中重复的值会被丢弃。 12&gt;&gt;&gt; set( 'letters' ) &#123;'l', 'e', 't', 'r', 's'&#125; 再试试用列表建立集合: 12&gt;&gt;&gt; set( ['Dasher', 'Dancer', 'Prancer', 'Mason-Dixon'] ) &#123;'Dancer', 'Dasher', 'Prancer', 'Mason-Dixon'&#125; 再试试元组: 12&gt;&gt;&gt; set( ('Ummagumma', 'Echoes', 'Atom Heart Mother') ) &#123;'Ummagumma', 'Atom Heart Mother', 'Echoes'&#125; 当字典作为参数传入 set() 函数时，只有键会被使用: 12set( &#123;'apple': 'red', 'orange': 'orange', 'cherry': 'red'&#125; )&#123;'apple', 'cherry', 'orange'&#125; 使用in测试值是否存在这是集合里最常用的功能。我们来建立一个叫 drinks 的字典。每个键都是一种混合饮料的 名字，与之对应的值是配料组成的集合: 1234567&gt;&gt;&gt; drinks = &#123;... 'martini': &#123;'vodka', 'vermouth'&#125;,... 'black russian': &#123;'vodka', 'kahlua'&#125;,... 'white russian': &#123;'cream', 'kahlua', 'vodka'&#125;,... 'manhattan': &#123;'rye', 'vermouth', 'bitters'&#125;,... 'screwdriver': &#123;'orange juice', 'vodka'&#125;... &#125; 尽管都由花括号{ }包裹，集合仅仅是一系列值组成的序列，而字典是一个或多个 键值对组成的序列。 哪种饮料含有伏特加？ 12345678&gt;&gt;&gt; for name, contents in drinks.items(): ... if 'vodka' in contents:... print(name)...screwdrivermartiniblack russianwhite russian 我想挑的饮料需要有伏特加，但不含乳糖。此外，我很讨厌苦艾酒，觉得它尝起来就像煤 油一样: 123456&gt;&gt;&gt; for name, contents in drinks.items():... if 'vodka' in contents and not ('vermouth' in contents or... 'cream' in contents):... print(name)screwdriverblack russian 合并及运算符如果想要查看多个集合之间组合的结果应该怎么办? 例如，你想要找到一种饮料，它含有果汁或含有苦艾酒。我们可以使用交集运算符，记作 &amp;: 123456&gt;&gt;&gt; for name, contents in drinks.items():... if contents &amp; &#123;'vermouth', 'orange juice'&#125;:... print(name)screwdrivermartinimanhattan &amp; 运算符的结果是一个集合，它包含所有同时出现在你比较的两个清单中的元素。 在上面代 码中，如果 contents 里面不包含任何一种指定成分，则 &amp; 会返回一个空集，相当于 False。现在来改写一下上一小节的例子，就是那个我们想要伏特加但不需要乳脂也不需要苦艾酒 的例子: 123456&gt;&gt;&gt; for name, contents in drinks.items():... if 'vodka' in contents and not contents &amp; &#123;'vermouth', 'cream'&#125;:... print(name)...screwdriverblack russian 将这两种饮料的原料都存储到变量中，以便于后面的例子不用再重复输入: 12&gt;&gt;&gt; bruss = drinks['black russian'] &gt;&gt;&gt; wruss = drinks['white russian'] 之后的例子会涵盖所有的集合运算符。 有些运算使用特殊定义过的标点，另一些则使用函数， 还有一些运算两者都可使用。 这里使用测试集合 a(包含 1 和 2)，以及 b(包含 2 和 3): 12&gt;&gt;&gt; a = &#123;1, 2&#125;&gt;&gt;&gt; b = &#123;2, 3&#125; 可以通过使用特殊标点符号 &amp; 或者集合函数intersection() 获取集合的交集(两集合共有 元素)，如下所示: 1234&gt;&gt;&gt; a &amp; b&#123;2&#125;&gt;&gt;&gt; a.intersection(b)&#123;2&#125; 下面的代码片段使用了我们之前存储的饮料变量: 12&gt;&gt;&gt; bruss &amp; wruss &#123;'kahlua', 'vodka'&#125; 下面的例子中，使用 | 或者 union() 函数来获取集合的并集(至少出现在一个集合中的元素): 1234&gt;&gt;&gt; a | b&#123;1, 2, 3&#125;&gt;&gt;&gt; a.union(b)&#123;1, 2, 3&#125; 使用字符- 或者 difference() 可以获得两个集合的差集(出现在第一个集合但不出现在第 二个集合): 12345678&gt;&gt;&gt; a - b&#123;1&#125;&gt;&gt;&gt; a.difference(b)&#123;1&#125;&gt;&gt;&gt; bruss - wruss set()&gt;&gt;&gt; wruss - bruss &#123;'cream'&#125; 使用 ^ 或者symmetric_difference() 可以获得两个集合的异或集(仅在两个集合中出现一次): 1234&gt;&gt;&gt; a ^ b&#123;1, 3&#125;&gt;&gt;&gt; a.symmetric_difference(b)&#123;1, 3&#125; 使用 &lt;= 或者issubset() 可以判断一个集合是否是另一个集合的子集(第一个集合的所有 元素都出现在第二个集合中): 1234&gt;&gt;&gt; a &lt;= bFalse&gt;&gt;&gt; a.issubset(b)False 一个集合是它本身的子集吗?答案为:是的。 1234&gt;&gt;&gt; a &lt;= aTrue&gt;&gt;&gt; a.issubset(a)True 当第二个集合包含所有第一个集合的元素，且仍包含其他元素时，我们称第一个集合为第 二个集合的真子集。使用 &lt; 可以进行判断: 1234&gt;&gt;&gt; a &lt; bFalse&gt;&gt;&gt; a &lt; aFalse 超集与子集正好相反(第二个集合的所有元素都出现在第一个集合中)，使用 &gt;= 或者 issuperset() 可以进行判断: 1234&gt;&gt;&gt; a &gt;= bFalse&gt;&gt;&gt; a.issuperset(b)False 一个集合是它本身的超集: 1234&gt;&gt;&gt; a &gt;= aTrue&gt;&gt;&gt; a.issuperset(a)True 最后，使用 &gt; 可以找到一个集合的真超集(第一个集合包含第二个集合的所有元素且还包 含其他元素): 12&gt;&gt;&gt; a &gt; b False 一个集合并不是它本身的真超集: 12&gt;&gt;&gt; a &gt; a False]]></content>
      <categories>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Python 序列]]></title>
    <url>%2F2018%2F02%2F06%2FPython%E5%88%97%E8%A1%A8%E5%92%8C%E5%85%83%E7%BB%84%2F</url>
    <content type="text"><![CDATA[序列成员有序排列的，并且可以通过下标 偏移量访问到它的一个或者几个成员，这类 Python 类型统称为序列。 包括下面这些：Python字符串，列表，和元组类型。 与字符串不同的是，元组和列表并不要求所含元素的种类相同，每个元素都可以是任 何 Python 类型的对象。 为什么 Python 需要同时设定列表和元组这两种序列呢？这是因为元组是不可变的，当你给 元组赋值时，这些值便被固定在了元组里，再也无法修改。然而，列表却是可变的，这意 味着可以随意地插入或删除其中的元素。 使用[]或list()创建列表列表可以由零个或多个元素组成，元素之间用逗号分开，整个列表被方括号所包裹： 1234&gt;&gt;&gt; empty_list = [ ]&gt;&gt;&gt; weekdays = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday'] &gt;&gt;&gt; big_birds = ['emu', 'ostrich', 'cassowary']&gt;&gt;&gt; first_names = ['Graham', 'John', 'Terry', 'Terry', 'Michael'] 也可以使用 list() 函数来创建一个空列表 123&gt;&gt;&gt; another_empty_list = list()&gt;&gt;&gt; another_empty_list[] 上面的例子中，只有 weekdays 列表充分利用了列表的顺序性。 first_names 则展示了列表 中的值允许重复这一性质。 如果你仅仅想要记录一些互不相同的值，而不在乎它们之间的顺序关系，集 合(set)会是一个更好的选择。在上面的例子中，big_birds 就更适合存储 在一个集合中。 使用list()将其他数据类型转换成列表Python 的 list() 函数可以将其他数据类型转换成列表类型。 12&gt;&gt;&gt; list('cat') ['c', 'a', 't'] 接下来的例子将一个元组转换成了列表: 123&gt;&gt;&gt; a_tuple = ('ready', 'fire', 'aim') &gt;&gt;&gt; list(a_tuple)['ready', 'fire', 'aim'] 使用 split() 可以依据分隔符将字符串切割成由若干子串组成的列表: 123&gt;&gt;&gt; birthday = '1/6/1952' &gt;&gt;&gt; birthday.split('/') ['1', '6', '1952'] 如果待分割的字符串中包含连续的分隔符，那么在返回的列表中会出现空串元素: 123&gt;&gt;&gt; splitme = 'a/b//c/d///e'&gt;&gt;&gt; splitme.split('/')['a', 'b', '', 'c', 'd', '', '', 'e'] 如果把上面例子中的分隔符改成 // 则会得到如下结果: 1234&gt;&gt;&gt; splitme = 'a/b//c/d///e' &gt;&gt;&gt; splitme.split('//')&gt;&gt;&gt;['a/b', 'c/d', '/e'] 使用[offset]获取元素通过偏移量可以从列表中提取对应位置的元素: 1234567&gt;&gt;&gt; marxes = ['Groucho', 'Chico', 'Harpo'] &gt;&gt;&gt; marxes[0]'Groucho'&gt;&gt;&gt; marxes[1]'Chico'&gt;&gt;&gt; marxes[2] 'Harpo' 负偏移量代表从尾部开始计数: 1234567&gt;&gt;&gt; marxes[-1] 'Harpo'&gt;&gt;&gt; marxes[-2] 'Chico'&gt;&gt;&gt; marxes[-3] 'Groucho'&gt;&gt;&gt; 包含列表的列表列表可以包含各种类型的元素，包括其他列表 1234&gt;&gt;&gt; small_birds = ['hummingbird', 'finch']&gt;&gt;&gt; extinct_birds = ['dodo', 'passenger pigeon', 'Norwegian Blue'] &gt;&gt;&gt; carol_birds = [3, 'French hens', 2, 'turtledoves']&gt;&gt;&gt; all_birds = [small_birds, extinct_birds, 'macaw', carol_birds] all_birds 这个列表的结构是什么样子的? 12&gt;&gt;&gt; all_birds[['hummingbird', 'finch'], ['dodo', 'passenger pigeon', 'Norwegian Blue'], 'macaw', [3, 'French hens', 2, 'turtledoves']] 使用[offset]修改元素就像可以通过偏移量访问某元素一样，你也可以通过赋值对它进行修改: 1234&gt;&gt;&gt; marxes = ['Groucho', 'Chico', 'Harpo'] &gt;&gt;&gt; marxes[2] = 'Wanda'&gt;&gt;&gt; marxes['Groucho', 'Chico', 'Wanda'] 指定范围并使用切片提取元素你可以使用切片提取列表的一个子序列: 123&gt;&gt;&gt; marxes = ['Groucho', 'Chico,' 'Harpo'] &gt;&gt;&gt; marxes[0:2]['Groucho', 'Chico'] 列表的切片仍然是一个列表。 与字符串一样，列表的切片也可以设定除 1 以外的步长。下面的例子从列表的开头开始每2 个提取一个元素: 12&gt;&gt;&gt; marxes[::2]['Groucho', 'Harpo'] 再试试从尾部开始提取，步长仍为 2: 12&gt;&gt;&gt; marxes[::-2] ['Harpo', 'Groucho'] 利用切片还可以巧妙地实现列表逆序: 12&gt;&gt;&gt; marxes[::-1]['Harpo', 'Chico', 'Groucho'] 使用append()添加元素至尾部传统的向列表中添加元素的方法是利用append() 函数将元素一个个添加到尾部。 123&gt;&gt;&gt; marxes.append('Zeppo')&gt;&gt;&gt; marxes['Groucho', 'Chico', 'Harpo', 'Zeppo'] 使用extend()或+=合并列表使用 extend()可以将一个列表合并到另一个列表中。 12345&gt;&gt;&gt; marxes = ['Groucho', 'Chico', 'Harpo', 'Zeppo'] &gt;&gt;&gt; others = ['Gummo', 'Karl']&gt;&gt;&gt; marxes.extend(others)&gt;&gt;&gt; marxes['Groucho', 'Chico', 'Harpo', 'Zeppo', 'Gummo', 'Karl'] 也可以使用+=: 12345&gt;&gt;&gt; marxes = ['Groucho', 'Chico', 'Harpo', 'Zeppo'] &gt;&gt;&gt; others = ['Gummo', 'Karl']&gt;&gt;&gt; marxes += others&gt;&gt;&gt; marxes['Groucho', 'Chico', 'Harpo', 'Zeppo', 'Gummo', 'Karl'] 如果错误地使用了 append()，那么 others 会被当成一个单独的元素进行添加，而不是将其中的内容进行合并: 12345&gt;&gt;&gt; marxes = ['Groucho', 'Chico', 'Harpo', 'Zeppo'] &gt;&gt;&gt; others = ['Gummo', 'Karl']&gt;&gt;&gt; marxes.append(others)&gt;&gt;&gt; marxes['Groucho', 'Chico', 'Harpo', 'Zeppo', ['Gummo', 'Karl']] 这个例子再次体现了列表可以包含不同类型的元素。上面的列表包含了四个字符串元素以及一个含有两个字符串的列表元素。 使用insert()在指定位置插入元素append() 函数只能将新元素插入到列表尾部，而使用insert()可以将元素插入到列表的任 意位置。 指定偏移量为 0 可以插入列表头部。如果指定的偏移量超过了尾部，则会插入到 列表最后，就如同 append()一样，这一操作不会产生 Python 异常。 123456&gt;&gt;&gt; marxes.insert(3, 'Gummo')&gt;&gt;&gt; marxes['Groucho', 'Chico', 'Harpo', 'Gummo', 'Zeppo']&gt;&gt;&gt; marxes.insert(10, 'Karl')&gt;&gt;&gt; marxes['Groucho', 'Chico', 'Harpo', 'Gummo', 'Zeppo', 'Karl'] 使用del删除指定位置的元素123&gt;&gt;&gt; del marxes[-1]&gt;&gt;&gt; marxes['Groucho', 'Chico', 'Harpo', 'Gummo', 'Zeppo'] del 是 Python 语句，而不是列表方法——无法通过 marxes[-2].del() 进行调 用。 del 就像是赋值语句(=)的逆过程:它将一个 Python 对象与它的名字 分离。如果这个对象无其他名称引用，则其占用空间也被会清除。 使用remove()删除具有指定值的元素如果不确定或不关心元素在列表中的位置，可以使用 remove() 根据指定的值删除元素。再见了，Gummo: 1234&gt;&gt;&gt; marxes = ['Groucho', 'Chico', 'Harpo', 'Gummo', 'Zeppo'] &gt;&gt;&gt; marxes.remove('Gummo')&gt;&gt;&gt; marxes['Groucho', 'Chico', 'Harpo', 'Zeppo'] 使用pop()获取并删除指定位置的元素使用pop() 同样可以获取列表中指定位置的元素，但在获取完成后，该元素会被自动删除。 如果你为pop() 指定了偏移量，它会返回偏移量对应位置的元素; 如果不指定，则默认使 用 -1。 因此，pop(0) 将返回列表的头元素，而 pop() 或 pop(-1) 则会返回列表的尾元素: 123456789&gt;&gt;&gt; marxes = ['Groucho', 'Chico', 'Harpo', 'Zeppo'] &gt;&gt;&gt; marxes.pop()'Zeppo'&gt;&gt;&gt; marxes['Groucho', 'Chico', 'Harpo'] &gt;&gt;&gt; marxes.pop(1)'Chico'&gt;&gt;&gt; marxes['Groucho', 'Harpo'] 使用index()查询具有特定值的元素位置如果想知道等于某一个值的元素位于列表的什么位置，可以使用 index() 函数进行查询: 123&gt;&gt;&gt; marxes = ['Groucho', 'Chico', 'Harpo', 'Zeppo'] &gt;&gt;&gt; marxes.index('Chico')1 使用in判断值是否存在判断一个值是否存在于给定的列表中有许多方式，其中最具有 Python 风格的是使用 in 12345&gt;&gt;&gt; marxes = ['Groucho', 'Chico', 'Harpo', 'Zeppo'] &gt;&gt;&gt; 'Groucho' in marxesTrue&gt;&gt;&gt; 'Bob' in marxesFalse 同一个值可能出现在列表的多个位置，但只要至少出现一次，in 就会返回 True: 123&gt;&gt;&gt; words = ['a', 'deer', 'a' 'female', 'deer'] &gt;&gt;&gt; 'deer' in wordsTrue 如果经常需要判断一个值是否存在于一个列表中，但并不关心列表中元素之 间的顺序，那么使用 Python 集合进行存储和查找会是更好的选择 使用count()记录特定值出现的次数使用count() 可以记录某一个特定值在列表中出现的次数: 123456789&gt;&gt;&gt; marxes = ['Groucho', 'Chico', 'Harpo'] &gt;&gt;&gt; marxes.count('Harpo')1&gt;&gt;&gt; marxes.count('Bob')0&gt;&gt;&gt; snl_skit = ['cheeseburger', 'cheeseburger', 'cheeseburger'] &gt;&gt;&gt; snl_skit.count('cheeseburger')3 使用join()转换为字符串join()一种新的使用方式: 123&gt;&gt;&gt; marxes = ['Groucho', 'Chico', 'Harpo']&gt;&gt;&gt; ', '.join(marxes)'Groucho, Chico, Harpo' join()函数的参数是字符串或者其他可迭代的包含字符串的序列(例如上面例 子中的字符串列表)，它的输出是一个字符串。 试着这样来记忆join() 的调用顺序: join() 是 split() 的逆过程，如下所示: 12345678910&gt;&gt;&gt; friends = ['Harry', 'Hermione', 'Ron'] &gt;&gt;&gt; separator = ' * '&gt;&gt;&gt; joined = separator.join(friends)&gt;&gt;&gt; joined'Harry * Hermione * Ron'&gt;&gt;&gt; separated = joined.split(separator) &gt;&gt;&gt; separated['Harry', 'Hermione', 'Ron']&gt;&gt;&gt; separated == friendsTrue 使用sort()重新排列元素在实际应用中，经常需要将列表中的元素按值排序，而不是按照偏移量排序。Python 为此 提供了两个函数: 列表方法 sort() 会对原列表进行排序，改变原列表内容; 通用函数 sorted() 则会返回排好序的列表副本，原列表内容不变。 如果列表中的元素都是数字，它们会默认地被排列成从小到大的升序。 如果元素都是字符 串，则会按照字母表顺序排列: 1234&gt;&gt;&gt; marxes = ['Groucho', 'Chico', 'Harpo'] &gt;&gt;&gt; sorted_marxes = sorted(marxes)&gt;&gt;&gt; sorted_marxes['Chico', 'Groucho', 'Harpo'] sorted_marxes 是一个副本，它的创建并不会改变原始列表的内容: 12&gt;&gt;&gt; marxes['Groucho', 'Chico', 'Harpo'] 但对 marxes 列表调用列表函数 sort()则会改变它的内容: 123&gt;&gt;&gt; marxes.sort()&gt;&gt;&gt; marxes['Chico', 'Groucho', 'Harpo'] 当列表中的所有元素都是同一种类型时(例如 marxes 中都是字符串)，sort() 会正常工 作。 有些时候甚至多种类型也可——例如整型和浮点型——只要它们之间能够自动地互相 转换: 1234&gt;&gt;&gt; numbers = [2, 1, 4.0, 3]&gt;&gt;&gt; numbers.sort()&gt;&gt;&gt; numbers[1, 2, 3, 4.0] 默认的排序是升序的，通过添加参数reverse=True 可以改变为降序排列: 1234&gt;&gt;&gt; numbers = [2, 1, 4.0, 3]&gt;&gt;&gt; numbers.sort(reverse=True)&gt;&gt;&gt; numbers[4.0, 3, 2, 1] 使用len()获取长度len()可以返回列表长度: 123&gt;&gt;&gt; marxes = ['Groucho', 'Chico', 'Harpo'] &gt;&gt;&gt; len(marxes)3 使用=赋值，使用copy()复制如果将一个列表赋值给了多个变量，改变其中的任何一处会造成其他变量对应的值也被修改，如下所示: 123456789&gt;&gt;&gt; a = [1, 2, 3]&gt;&gt;&gt; a[1, 2, 3]&gt;&gt;&gt; b = a&gt;&gt;&gt; b[1, 2, 3]&gt;&gt;&gt; a[0] = 'surprise' &gt;&gt;&gt; a['surprise', 2, 3] 现在，b 的值是什么?它会保持 [1, 2, 3]，还是改变为 [‘surprise’, 2, 3] ?试一试: 12&gt;&gt;&gt; b['surprise', 2, 3] b 与 a 实际上指向的是同一个对象，因此，无论我们是通过 a 还是通过 b 来修改列表的内容，其结果都会作用于双方: 1234567&gt;&gt;&gt; b['surprise', 2, 3]&gt;&gt;&gt; b[0] = 'I hate surprises' &gt;&gt;&gt; b['I hate surprises', 2, 3] &gt;&gt;&gt; a['I hate surprises', 2, 3] 通过下面任意一种方法，都可以将一个列表的值复制到另一个新的列表中: 列表 copy() 函数 list() 转换函数 列表分片[:] 测试初始时我们的列表叫作 a，然后利用copy() 函数创建 b，利用list() 函数创建 c，并 使用列表分片创建 d: 1234&gt;&gt;&gt; a = [1, 2, 3]&gt;&gt;&gt; b = a.copy()&gt;&gt;&gt; c = list(a)&gt;&gt;&gt; d = a[:] 再次注意，在这个例子中，b、c、d 都是 a 的复制:它们是自身带有值的新对象，与原始 的 a 所指向的列表对象 [1, 2, 3] 没有任何关联。改变 a 不影响 b、c 和 d 的复制。 使用()创建元组可以用 () 创建一个空元组: 123&gt;&gt;&gt; empty_tuple = ()&gt;&gt;&gt; empty_tuple() 创建包含一个或多个元素的元组时，每一个元素后面都需要跟着一个逗号，即使只包含一 个元素也不能省略: 123&gt;&gt;&gt; one_marx = 'Groucho', &gt;&gt;&gt; one_marx('Groucho',) 如果创建的元组所包含的元素数量超过 1，最后一个元素后面的逗号可以省略: 123&gt;&gt;&gt; marx_tuple = 'Groucho', 'Chico', 'Harpo' &gt;&gt;&gt; marx_tuple('Groucho', 'Chico', 'Harpo') Python 的交互式解释器输出元组时会自动添加一对圆括号。你并不需要这么做——定义元 组真正靠的是每个元素的后缀逗号； 但如果你习惯添加一对括号也无可厚非。可以用括 号将所有元素包裹起来，这会使得程序更加清晰: 123&gt;&gt;&gt; marx_tuple = ('Groucho', 'Chico', 'Harpo') &gt;&gt;&gt; marx_tuple('Groucho', 'Chico', 'Harpo') 可以一口气将元组赋值给多个变量: 12345678&gt;&gt;&gt; marx_tuple = ('Groucho', 'Chico', 'Harpo') &gt;&gt;&gt; a, b, c = marx_tuple&gt;&gt;&gt; a'Groucho'&gt;&gt;&gt; b'Chico' &gt;&gt;&gt; c 'Harpo' 有时这个过程被称为元组解包。 可以利用元组在一条语句中对多个变量的值进行交换，而不需要借助临时变量: 1234567&gt;&gt;&gt; password = 'swordfish'&gt;&gt;&gt; icecream = 'tuttifrutti'&gt;&gt;&gt; password, icecream = icecream, password &gt;&gt;&gt; password'tuttifrutti'&gt;&gt;&gt; icecream'swordfish' tuple() 函数可以用其他类型的数据来创建元组: 123&gt;&gt;&gt; marx_list = ['Groucho', 'Chico', 'Harpo'] &gt;&gt;&gt; tuple(marx_list)('Groucho', 'Chico', 'Harpo') 与序列相关的内建函数sorted()， reversed()， enumerate()，zip()其中两个函 数 sorted() 和zip() 返回一个序列(列表)， 而另外两个函数reversed() 和 enumerate() 返回迭代器(类似序列) 123456&gt;&gt;&gt; albums = ('Poe', 'Gaudi', 'Freud', 'Poe2')&gt;&gt;&gt; years = (1976, 1987, 1990, 2003)&gt;&gt;&gt; for album in sorted(albums): ... print album,...Freud Gaudi Poe Poe2 1234&gt;&gt;&gt; for album in reversed(albums):... print album,...Poe2 Freud Gaudi Poe 1234567&gt;&gt;&gt; for i, album in enumerate(albums): ... print i, album...0 Poe1 Gaudi2 Freud3 Poe2 123456&gt;&gt;&gt; for album, yr in zip(albums, years): ... print yr, album1976 Poe1987 Gaudi1990 Freud2003 Poe2 序列类型操作符成员关系操作符 in, not in成员关系操作符使用来判断一个元素是否属于一个序列的。比如对字符串类型来说，就是 判断一个字符是否属于这个字符串，对和元组类型来说，就代表了一个对象是否属于该对象序 列。in、not in 操作符的返回值一般来讲就是 True或False，满足成员关系就返回 True，否则返 回 False。该操作符的语法如下: 1obj [not] in sequence 连接操作符 +这个操作符允许我们把一个序列和另一个相同类型的序列做连接。语法如下: 1sequence1 + sequence2 该表达式的结果是一个包含 sequence1 和 sequence2 的内容的新序列。 注意，这种方式看 起来似乎实现了把两个序列内容合并的概念，但是这个操作不是最快或者说最有效的。 对字符串来说，这个操作不如把所有的子字符串放到一个列表或可迭代对象中，然后调用一个join()方法来把所有的内容连接在一起节约内存； 对列表来说，我们推荐读者用列表类型的 extend()方法来把两个或者多个列表对象合并。 当你需要简单地把两个对象的内容合并，或者说 不能依赖于可变对象的那些没有返回值(实际上它返回一个 None)的内建方法来完成的时候时， 连接操作符还是很方便的一个选择。下面的切片操作可以视作这些情况的例子。 重复操作符 *当你需要需要一个序列的多份拷贝时，重复操作符非常有用，它的语法如下: 1sequence * copies_int copies_int 必须是一个整数(不能是长整数)。 像连接操作符一样，该操作符返回一个新的包含多份原对象拷贝的对象。 切片操作符 [], [:],[::]序列类型是其元素 被顺序放置的一种数据结构类型，这种方式允许通过指定下标的方式来获得某一个数据元素，或 者通过指定下标范围来获得一组序列的元素。这种访问序列的方式叫做切片。访问某一个数据元素的语法如下: 1sequence[index] sequence 是序列的名字，index 是想要访问的元素对应的偏移量。 偏移量可以是正值，范围 从 0 到偏移最大值(比序列长度少一)，用 len()函数可以得到序列长度，实际 的范围是0 &lt;= inde &lt;= len(sequece)-1 。 另外，也可以使用负索引，范围是 -1 到序列的负 长度，-len(sequence)，-len(sequence) &lt;= index &lt;= -1。 正负索引的区别在于正索引以序列 的开始为起点，负索引以序列的结束为起点。 试图访问一个越界的索引会引发一个如下的异常: 1234&gt;&gt;&gt; names = ('Faye', 'Leanna', 'Daylen')&gt;&gt;&gt; print names[4]Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in ?IndexError: tuple index out of range 你可以像下面这样直接访问一个序列的元素(不用先把它赋值给一个变量): 12&gt;&gt;&gt; print ('Faye', 'Leanna', 'Daylen')[1] Leanna 这个特性在你调用一个返回值是序列类型的函数，并且你只对返回的序列中的一个或某几 个元素感兴趣时特别有用 那么我们如何才能一次得到多个元素呢？语法如下: 1sequence[starting_index:ending_index] 通过这种方式我们可以得到从起始索引到结束索引（不包括结束索引对应的元素）之间的 一”片”元素。 起始索引和结束索引都是可选的，如果没有提供或者用 None 作为索引值，切片操作 会从序列的最开始处开始，或者直到序列的最末尾结束. 用步长索引来进行扩展的切片操作切片操作符的第三个索引值被用做步长参数。以下是几个例子: 翻转序列： 123&gt;&gt;&gt; s = 'abcdefgh'&gt;&gt;&gt; s[::-1] # 可以视作"翻转"操作'hgfedcba' 隔一个取一个的操作： 12&gt;&gt;&gt; s[::2] 'aceg' 开始和结束素引值可以超过字符串的 长度。 换句话说，起始索引可以小于 0，而对于结束索引，即使索引值为 100 的元素并不存在也 不会报错，例子如下: 12&gt;&gt;&gt; ('Faye', 'Leanna', 'Daylen')[-100:100]('Faye', 'Leanna', 'Daylen') 有这么一个问题：有一个字符串，我们想通过一个循环按照这样的形式显示它:每次都把 位于最后的一个字符砍掉，下面是实现这个要求的一种方法: 123456789&gt;&gt;&gt; s = 'abcde'&gt;&gt;&gt; i = -1&gt;&gt;&gt; for i in range(-1, -len(s), -1):... print s[:i]... abcdabcab a 可是，该如何在第一次迭代的时候显示整个字符串呢？ 事实 上在一个以负数作为索引的例子里是没有一个真正能解决这个问题的方法的，因为-1 已经是“最 小”的索引了。我们不可能用0来作为索引值，因为这会切片到第一个元素之前而什么都不会显 示: 12&gt;&gt;&gt; s[:0]'' 我们的方案是使用另一个小技巧：用 None 作为索引值，这样一来就可以满足你的需要，比如说，在你想用一个变量作为索引来从第一个到遍历最后一个元素的时候： 123456789&gt;&gt;&gt; s = 'abcde'&gt;&gt;&gt; for i in [None] + range(-1, -len(s), -1):... print s[:i]...abcdeabcdabcaba 在进行下面的内容之前，必须指出，似乎还可以先创建 一个只包含 None 的列表，然后用 extend()函数把 range()的输出添加到这个列表； 或者先建立range()输出组成的列表然后再把 None 插入到这个列表的最前面，然后对这个列表进行遍历；但是可变对象的内建函数 extend()根本就没有返回值，所以这个方法是行不通的: 123456&gt;&gt;&gt; for i in [None].extend(range(-1, -len(s), -1)):... print s[:i]...Traceback (most recent call last):File "&lt;stdin&gt;", line 1, in ?TypeError: iteration over non-sequence 这个错误发生的原因是[None].extend(…)函数返回None ， None 既不是序列类型也不是 可迭代对象。 这种情况下使用上面提到的的列表连接操作来实现是唯一不需要添加额外代码的 方法。 类型转换内建函数list()，str()和 tuple()被用做在各种序列类型之间转换。但是并没有进行任何的转换。 这些转换实际上是工厂函数，将对象作为参数，并将其内容(浅)拷贝到新生成的对象中。 函数 含义 list(iter) 把可迭代对象转换为列表 str(obj) 把 obj 对象转换成字符串(对象的字符串表示法) unicode(obj) 把对象转换成 Unicode 字符串(使用默认编码) basestring() 抽象工厂函数,其作用仅仅是为 str 和 unicode 函数提供父类，所以不能被实例化，也不能被调用 tuple(iter) 把一个可迭代对象转换成一个元组对象 不过，为什么 Python 里面不简单地把一个对象转换成另 一个对象呢？ 一旦一个 Python 的对象被建立，我们就不能更改 其身份或类型了。如果你把一个列表对象传给 list()函数，便会创建这个对象的一个浅拷贝， 然后将其插入新的列表中。 同样地，在做连接操作和重复操作时，也是这样处理的。 所谓浅拷贝就是只拷贝了对对象的索引，而不是重新建立了一个对象！如果你想完全的拷 贝一个对象(包括递归，如果你的对象是一个包含在容器中的容器)，你需要用到深拷贝。 元组与列表在许多地方都可以用元组代替列表，但元组的方法函数与列表相比要少一些， 元组没有 append()、insert()，等等， 因为一旦创建元组便无法修改。既然列表更加灵活，那为 什么不在所有地方都使用列表呢?原因如下所示: 元组占用的空间较小 你不会意外修改元组的值 可以将元组用作字典的键 命名元组可以作为对象的替代 函数的参数是以元组形式传递的]]></content>
      <categories>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Python 字符串]]></title>
    <url>%2F2018%2F02%2F05%2FPython%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[字符串是不可变类型，就是说改变一个字符串的元素需要新建一个新的字符串。 Python2 实际上有 3 类字符串。通常意 义的字符串str和 Unicode 字符串unicode实际上都是抽象类 basestring 的子类。 这个 basestring 是不能实例化的 使用引号创建将一系列字符包裹在一对单引号或一对双引号中即可创建字符串，就像下面这样： 1234&gt;&gt;&gt; 'Snap' 'Snap'&gt;&gt;&gt; "Crackle" 'Crackle' 交互式解释器输出的字符串永远是用单引号包裹的，但无论使用哪种引号，Python 对字符 串的处理方式都是一样的，没有任何区别。 既然如此，为什么要使用两种引号？这么做的好处是可以创建本身就包含引号的字符串， 而不用使用转义符。可以在双引号包裹的字符串中使用单引号，或者在单引号包裹的字符 串中使用双引号： 1234567&gt;&gt;&gt; "'Nay,' said the naysayer.""'Nay,' said the naysayer."&gt;&gt;&gt; 'The rare double quote in captivity: ".''The rare double quote in captivity: ".'&gt;&gt;&gt; 'A "two by four" is actually 1 1⁄2" × 3 1⁄2".''A "two by four is" actually 1 1⁄2" × 3 1⁄2".'&gt;&gt;&gt; "'There's the man that shot my paw!' cried the limping hound." "'There's the man that shot my paw!' cried the limping hound." 你还可以使用连续三个单引号 &#39;&#39;&#39;，或者三个双引号 &quot;&quot;&quot; 创建字符串： 1234&gt;&gt;&gt; '''Boom!''' 'Boom'&gt;&gt;&gt; """Eek!""" 'Eek!' 三元引号在创建短字符串时没有什么特殊用处。它多用于创建多行字符串： 123456&gt;&gt;&gt; poem = '''There was a Young Lady of Norway,... Who casually sat in a doorway;... When the door squeezed her flat,... She exclaimed, "What of that?"... This courageous Young Lady of Norway.'''&gt;&gt;&gt; 在三元引号包裹的字符串中，每行的换行符以及行首或行末的空格都会被保留： 1234567891011&gt;&gt;&gt; poem2 = '''I do not like thee, Doctor Fell.... The reason why, I cannot tell.... But this I know, and know full well:... I do not like thee, Doctor Fell.... '''&gt;&gt;&gt; print(poem2)I do not like thee, Doctor Fell. The reason why, I cannot tell. But this I know, and know full well: I do not like thee, Doctor Fell.&gt;&gt;&gt; 值得注意的是，print() 函数的输出与交互式解释器的自动响应输出存在一些差异： 12&gt;&gt;&gt; poem2'I do not like thee, Doctor Fell.\n The reason why, I cannot tell.\n But this I know, and know full well:\n I do not like thee, Doctor Fell.\n' print()会把包裹字符串的引号截去，仅输出其实际内容，易于阅读。它还会自动地在各 个输出部分之间添加空格，并在所有输出的最后添加换行符： 12&gt;&gt;&gt; print(99, 'bottles', 'would be enough.') 99 bottles would be enough. 如果你不希望print() 自动添加空格或换行，随后将学会如何避免它们。 最后要指出的是 Python 允许空串的存在，它不包含任何字符且完全合法： 12345678&gt;&gt;&gt; ''''&gt;&gt;&gt; ""''&gt;&gt;&gt; ''''''''&gt;&gt;&gt; """"""'' 为什么会用到空字符串？有些时候你想要创建的字符串可能源自另一字符串的内容，这时 需要先创建一个空白的模板，也就是一个空字符串。 123456&gt;&gt;&gt; bottles = 99&gt;&gt;&gt; base = ''&gt;&gt;&gt; base += 'current inventory: ' &gt;&gt;&gt; base += str(bottles)&gt;&gt;&gt; base'current inventory: 99' 字符串是一个序列字符串是由字符组成的序列。你可以用括号运算符一次访问一个字符: 12&gt;&gt;&gt; fruit = 'banana'&gt;&gt;&gt; letter = fruit[1] 使用str()进行类型转换使用str() 可以将其他 Python 数据类型转换为字符串： 123456&gt;&gt;&gt; str(98.6) '98.6'&gt;&gt;&gt; str(1.0e4) '10000.0'&gt;&gt;&gt; str(True) 'True' 当你调用 print() 函数或者进行字符串差值(string interpolation)时，Python 内部会自动 使用 str() 将非字符串对象转换为字符串。 使用\转义Python 允许你对某些字符进行转义操作，以此来实现一些难以单纯用字符描述的效果。在 字符的前面添加反斜线符号\ 会使该字符的意义发生改变。最常见的转义符是 \n，它代表 换行符，便于你在一行内创建多行字符串。 123456&gt;&gt;&gt; palindrome = 'A man,\nA plan,\nA canal:\nPanama.' &gt;&gt;&gt; print(palindrome)A man,A plan,A canal:Panama. 转义符 \t(tab 制表符)常用于对齐文本： 123456&gt;&gt;&gt; print('\tabc') abc&gt;&gt;&gt; print('a\tbc') a bc&gt;&gt;&gt; print('ab\tc') ab c 有时你可能还会用到 \&#39; 和 \&quot; 来表示单、双引号，尤其当该字符串由相同类型的引号包裹时: 1234567&gt;&gt;&gt; testimony = "\"I did nothing!\" he said. \"Not that either! Or the other thing.\""&gt;&gt;&gt; print(testimony)"I did nothing!" he said. "Not that either! Or the other thing."&gt;&gt;&gt; fact = "The world's largest rubber duck was 54'2\" by 65'7\" by 105'"&gt;&gt;&gt; print(fact)The world's largest rubber duck was 54'2" by 65'7" by 105' 如果你需要输出一个反斜线字符，连续输入两个反斜线即可: 123&gt;&gt;&gt; speech = 'Today we honor our friend, the backslash: \\.' &gt;&gt;&gt; print(speech)Today we honor our friend, the backslash: \. 使用+拼接在 Python 中，你可以使用 + 将多个字符串或字符串变量拼接起来，就像下面这样: 12&gt;&gt;&gt; 'Release the kraken! ' + 'At once!' 'Release the kraken! At once!' 也可以直接将一个字面字符串(非字符串变量)放到另一个的后面直接实现拼接: 12&gt;&gt;&gt; "My word! " "A gentleman caller!"'My word! A gentleman caller!' 进行字符串拼接时，Python 并不会自动为你添加空格，需要显示定义。但当我们调用print() 进行打印时，Python 会在各个参数之间自动添加空格并在结尾添加换行符: 1234567&gt;&gt;&gt; a = 'Duck.'&gt;&gt;&gt; b = a&gt;&gt;&gt; c = 'Grey Duck!' &gt;&gt;&gt; a + b + c 'Duck.Duck.Grey Duck!' &gt;&gt;&gt; print(a, b, c) Duck. Duck. Grey Duck! 使用*复制使用 * 可以进行字符串复制。 1234&gt;&gt;&gt; start = 'Na ' * 4 + '\n'&gt;&gt;&gt; middle = 'Hey ' * 3 + '\n'&gt;&gt;&gt; end = 'Goodbye.'&gt;&gt;&gt; print(start + start + middle + end) 使用[]提取字符在字符串名后面添加 []，并在括号里指定偏移量可以提取该位置的单个字符。第一个字符 (最左侧)的偏移量为0，下一个是1，以此类推。最后一个字符(最右侧)的偏移量也可以用 -1 表示，这样就不必从头数到尾。偏移量从右到左紧接着为 -2、-3，以此类推。 12345678910111213&gt;&gt;&gt; letters = 'abcdefghijklmnopqrstuvwxyz' &gt;&gt;&gt; letters[0]'a'&gt;&gt;&gt; letters[1]'b'&gt;&gt;&gt; letters[-1] 'z'&gt;&gt;&gt; letters[-2] 'y'&gt;&gt;&gt; letters[25] 'z'&gt;&gt;&gt; letters[5] 'f' 字符串是不可变的跟数字类型一样，由于字符串是不可变的，因此你无法直接插入字符或改变指定位置的字符 12345&gt;&gt;&gt; name = 'Henny'&gt;&gt;&gt; naume[0] = 'P'Traceback (most recent call last):File "&lt;stdin&gt;", line 1, in &lt;module&gt;TypeError: 'str' object does not support item assignment 为了改变字符串，我们需要组合使用一些字符串函数，例如replace()，以及分片操作: 12345&gt;&gt;&gt; name = 'Henny'&gt;&gt;&gt; name.replace('H', 'P') 'Penny'&gt;&gt;&gt; 'P' + name[1:]'Penny' 字符串的比较在做比较操作的时候，字符串是按照 ASCII 值的大小来比较的. 123456789&gt;&gt;&gt; str1 = 'abc'&gt;&gt;&gt; str2 = 'lmn'&gt;&gt;&gt; str3 = 'xyz'&gt;&gt;&gt; str1 &lt; str2True&gt;&gt;&gt; str2 != str3True&gt;&gt;&gt; str1 &lt; str3 and str2 == 'xyz'False 使用[start:end:step]分片分片操作(slice)可以从一个字符串中抽取子字符串(字符串的一部分)。 我们使用一对方 括号、起始偏移量 start、终止偏移量 end 以及可选的步长 step 来定义一个分片。其中一 些可以省略。 分片得到的子串包含从 start 开始到 end 之前的全部字符。 [:] 提取从开头到结尾的整个字符串 [start:] 从 start 提取到结尾 [:end] 从开头提取到 end - 1 [start:end] 从 start 提取到 end - 1 [start:end:step] 从 start 提取到 end - 1，每 step 个字符提取一个 偏移量从左至右从 0、1 开始，依次增加； 从右至左从-1、-2 开始，依次减 小。 如果省略 start，分片会默认使用偏移量 0(开头)； 如果省略 end，分片会默认使用 偏移量 -1(结尾)。 我们来创建一个由小写字母组成的字符串: 1&gt;&gt;&gt; letters = 'abcdefghijklmnopqrstuvwxyz' 仅仅使用: 分片等价于使用 0 : -1(也就是提取整个字符串): 12&gt;&gt;&gt; letters[:] 'abcdefghijklmnopqrstuvwxyz' 下面是一个从偏移量 20 提取到字符串结尾的例子: 12&gt;&gt;&gt; letters[20:]'uvwxyz' 下一个例子提取了偏移量从 12 到 14 的字符: 12&gt;&gt;&gt; letters[12:15] 'mno' 提取最后三个字符: 12&gt;&gt;&gt; letters[-3:] 'xyz' 下面一个例子提取了从偏移量为 18 的字符到倒数第 4 个字符。 注意与上一个例子的区别: 当偏移量 -3 作为开始位置时，将获得字符 x;而当它作为终止位置时，分片实际上会在偏 移量 -4 处停止，也就是提取到字符 w: 12&gt;&gt;&gt; letters[18:-3] 'stuvw' 接下来，试着提取从倒数第 6 个字符到倒数第 3 个字符: 12&gt;&gt;&gt; letters[-6:-2]'uvwx' 如果你需要的步长不是默认的 1，可以在第二个冒号后面进行指定。 从开头提取到结尾，步长设为 7: 12&gt;&gt;&gt; letters[::7] 'ahov' 从偏移量 4 提取到偏移量 19，步长设为 3: 12&gt;&gt;&gt; letters[4:20:3]'ehknqt' 从偏移量 19 提取到结尾，步长设为 4: 12&gt;&gt;&gt; letters[19::4] 'tx' 从开头提取到偏移量 20，步长设为 5: 12&gt;&gt;&gt; letters[:21:5]'afkpu' 记住，分片中 end 的偏移量需要比实际提取的最后一个字符的偏移量多 1。 如果指定的步长为负数，机智的 Python 还会从右到左反 向进行提取操作。 下面这个例子便从右到左以步长为 1 进行提取: 12&gt;&gt;&gt; letters[-1::-1] 'zyxwvutsrqponmlkjihgfedcba' 事实上，你可以将上面的例子简化为下面这种形式，结果完全一致: 12&gt;&gt;&gt; letters[::-1] 'zyxwvutsrqponmlkjihgfedcba' 分片操作对于无效偏移量的容忍程度要远大于单字符提取操作。在分片中，小于起始位置的 偏移量会被当作 0，大于终止位置的偏移量会被当作 -1。 提取倒数 50 个字符: 12&gt;&gt;&gt; letters[-50:]'abcdefghijklmnopqrstuvwxyz' 提取从倒数第 51 到倒数第 50 个字符: 12&gt;&gt;&gt; letters[-51:-50]'' 从开头提取到偏移量为 69 的字符: 12&gt;&gt;&gt; letters[:70]'abcdefghijklmnopqrstuvwxyz' 从偏移量为 70 的字符提取到偏移量为 71 的字符: 12&gt;&gt;&gt; letters[70:71]'' 使用len()获得长度len() 函数可用于计算字符串包含的字符数: 12345&gt;&gt;&gt; len(letters)26&gt;&gt;&gt; empty = ""&gt;&gt;&gt; len(empty)0 也可以对其他的序列类型使用 len() 使用split()分割与广义函数len() 不同，有些函数只适用于字符串类型。使用内置的字符串函数 split()可以基于分隔符将字符串分割成由若干子串组成的列表。 123&gt;&gt;&gt; todos = 'get gloves,get mask,give cat vitamins,call ambulance' &gt;&gt;&gt; todos.split(',')['get gloves', 'get mask', 'give cat vitamins', 'call ambulance'] 如 果不指定分隔符，那么 split() 将默认使用空白字符——换行符、空格、制表符。 12&gt;&gt;&gt; todos.split()['get', 'gloves,get', 'mask,give', 'cat', 'vitamins,call', 'ambulance'] 使用join()合并join() 函数与 split()函数正好相反：它将包含若干子串的列表分 解，并将这些子串合成一个完整的大的字符串。 join()的调用顺序看起来有点别扭，与 split() 相反，你需要首先指定粘合用的字符串，然后再指定需要合并的列表：string. join(list)。 因此，为了将列表 lines 中的多个子串合并成完整的字符串，我们应该使用语 句：&#39;\n&#39;.join(lines)。 下面的例子将列表中的名字通过逗号及空格粘合在一起: 1234&gt;&gt;&gt; crypto_list = ['Yeti', 'Bigfoot', 'Loch Ness Monster']&gt;&gt;&gt; crypto_string = ', '.join(crypto_list)&gt;&gt;&gt; print('Found and signing book deals:', crypto_string) Found and signing book deals: Yeti, Bigfoot, Loch Ness Monster 其他常用字符串相关函数我们的测试对象是下面的字符串 123456&gt;&gt;&gt; poem = '''All that doth flow we cannot liquid nameOr else would fire and water be the same;But that is liquid which is moist and wetFire that property can never get.Then 'tis not cold that doth the fire put out But 'tis the wet that makes it die, no doubt.''' 这首诗有多少个字符呢?(计入空格和换行符。) 12&gt;&gt;&gt; len(poem)250 这首诗是不是以 All 开头呢? 12&gt;&gt;&gt; poem.startswith('All')True 它是否以 That’s all, folks!? 结尾? 12&gt;&gt;&gt; poem.endswith('That\'s all, folks!') False 查一查诗中第一次出现单词 the 的位置(偏移量): 123&gt;&gt;&gt; word = 'the' &gt;&gt;&gt; poem.find(word) 73 以及最后一次出现 the 的偏移量 : 12&gt;&gt;&gt; poem.rfind(word)214 the 在这首诗中出现了多少次? 12&gt;&gt;&gt; poem.count(word)3 诗中出现的所有字符都是字母或数字吗? 12&gt;&gt;&gt; poem.isalnum()False 并非如此，诗中还包括标点符号。 大小写与对齐方式我们的测试字符串如下所示: 1&gt;&gt;&gt; setup = 'a duck goes into a bar...' 将字符串收尾的. 都删除掉: 12&gt;&gt;&gt; setup.strip('.')'a duck goes into a bar' 由于字符串是不可变的，上面这些例子实际上没有一个对 setup 真正做了修 改。它们都仅仅是获取了 setup 的值，进行某些操作后将操作结果赋值给了 另一个新的字符串而已。 让字符串首字母变成大写: 12&gt;&gt;&gt; setup.capitalize()'A duck goes into a bar...' 让所有单词的开头字母变成大写: 12&gt;&gt;&gt; setup.title()'A Duck Goes Into A Bar...' 让所有字母都变成大写: 12&gt;&gt;&gt; setup.upper()'A DUCK GOES INTO A BAR...' 将所有字母转换成小写: 12&gt;&gt;&gt; setup.lower()'a duck goes into a bar...' 将所有字母的大小写转换: 12&gt;&gt;&gt; setup.swapcase()'a DUCK GOES INTO A BAR...' 再来看看与格式排版相关的函数。这里，我们假设例子中的字符串被排版在指定长度(这 里是 30 个字符)的空间里。 在 30 个字符位居中: 12&gt;&gt;&gt; setup.center(30)' a duck goes into a bar... ' 左对齐: 12&gt;&gt;&gt; setup.ljust(30)'a duck goes into a bar... ' 右对齐: 12&gt;&gt;&gt; setup.rjust(30)' a duck goes into a bar...' 使用replace()替换使用 replace() 函数可以进行简单的子串替换。 你需要传入的参数包括：需要被替换的子 串，用于替换的新子串，以及需要替换多少处。最后一个参数如果省略则默认只替换第一次出现的位置: 12&gt;&gt;&gt; setup.replace('duck', 'marmoset') 'a marmoset goes into a bar...' 修改最多 100 处： 12&gt;&gt;&gt; setup.replace('a ', 'a famous ', 100)'a famous duck goes into a famous bar...' 当你准确地知道想要替换的子串是什么样子时，replace() 是个非常不错的选择。但使用 时一定要小心! 在上面第二个例子中，如果我们粗心地把需要替换的子串写成了单个字符 的 ‘a’ 而不是两个字符的 ‘a ‘(a 后面跟着一个空格)的话，会错误地将所有单词中出现 的 a 也一并替换了: 12&gt;&gt;&gt; setup.replace('a', 'a famous', 100)'a famous duck goes into a famous ba famousr...']]></content>
      <categories>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Python 内置数据类型]]></title>
    <url>%2F2018%2F02%2F04%2FPython%E5%86%85%E7%BD%AE%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[Python 里一切都是以对象(object)的形式存在的。 内置数据类型在 Python 中您并不需要声明变量的数据类型。Python 根据每 个变量的初始赋值情况分析其类型，并在内部对其进行跟踪。 type()函数查看对象类型在 Python 中，如果想知道一个对象(例如一个变量或者一个字面值)的类型，可以使用语 句：type( thing )。 12345678910&gt;&gt;&gt; type(a) &lt;class 'int'&gt; &gt;&gt;&gt; type(b) &lt;class 'int'&gt; &gt;&gt;&gt; type(58) &lt;class 'int'&gt; &gt;&gt;&gt; type(99.9)&lt;class 'float'&gt; &gt;&gt;&gt; type('abc') &lt;class 'str'&gt; isinstance() 函数判断某个值或变量是否为给定某个类型。12&gt;&gt;&gt; isinstance(1, int) True 布尔型Python 有两个被巧妙地命名为 True 和 False 的常量，可用于对布尔类型的直接赋值。 数值型Python 本身支持整数(比如 5 和 1000000000)以及浮点数(比如 3.1416、14.99 和 1.87e4)。你可以对这些数字进行下表中的计算。 运算符 描述 示例 运算结果 + 加法 5 + 8 13 - 减法 90 – 10 80 * 乘法 4 * 7 28 / 除法 7 / 2 3.5 // 取整除（返回商的整数部分） 7 // 2 3 % 模（求余） 7 % 3 1 ** 幂 3 ** 4 81 整数int任何仅含数字的序列在 Python 中都被认为是整数: 12&gt;&gt;&gt; 55 你可以单独使用数字零(0): 12&gt;&gt;&gt; 00 但不能把它作为前缀放在其他数字前面: 123456&gt;&gt;&gt; 05 File "&lt;stdin&gt;", line 1 05 ^SyntaxError: invalid token&gt;&gt;&gt; 一个数字序列定义了一个正整数。你也可以显式地在前面加上正号 +，这不会使数字发生 任何改变: 1234&gt;&gt;&gt; 123123&gt;&gt;&gt; +123123 在数字前添加负号 - 可以定义一个负数: 12&gt;&gt;&gt; -123-123 除法运算比较有意思，可能与你预期的有些出入，因为 Python 里有两种除法: / 用来执行浮点除法(十进制小数) // 用来执行整数除法(整除) 与其他语言不同，在 Python 中即使运算对象是两个整数，使用 / 仍会得到浮点型的结果: 12&gt;&gt;&gt; 9 / 5 1.8 使用整除运算得到的是一个整数，余数会被截去: 12&gt;&gt;&gt; 9 // 5 1 如果除数为 0，任何一种除法运算都会产生 Python 异常: 123456789&gt;&gt;&gt; 5 / 0Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;ZeroDivisionError: division by zero&gt;&gt;&gt; 7 // 0Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;ZeroDivisionError: integer division or modulo by zero&gt;&gt;&gt; Python 还支持以下写法 1234&gt;&gt;&gt; a = 95&gt;&gt;&gt; a -= 3&gt;&gt;&gt; a92 使用下面的方法可以同时得到余数和商: 12&gt;&gt;&gt; divmod(9,5)(1, 4) 上面的代码出现了一些你没见过的新东西:一个叫作 divmod 的函数。这个函数接受了两个 整数:9 和 5，并返回了一个包含两个元素的结果，我们称这种结构为元组(tuple)。 运算优先级建议总是使用括号来保证运算顺序与我们期望的一致: 12&gt;&gt;&gt; 2 + (3 * 4)14 基数在 Python 中，整数默认使用十进制数，除非你在数字前添加前缀，显式地指 定使用其他基数(base)。 在 Python 中，除十进制外你还可以使用其他三种进制的数字: 0b 或 0B 代表二进制(以 2 为底) 0o 或 0O 代表八进制(以 8 为底) 0x 或 0X 代表十六进制(以 16 为底) Python 解释器会打印出它们对应的十进制整数： 123456&gt;&gt;&gt; 0b102&gt;&gt;&gt; 0o108&gt;&gt;&gt; 0x1016 使用int()函数转换为整型我们可以方便地使用 int() 函数将其他的 Python 数据类型转换为整型。它会保留传入数据的整数部分并舍去小数部分。 Python 里最简单的数据类型是布尔型，它只有两个可选值：True 和 False。当转换为整数时，它们分别代表 1 和 0： 1234&gt;&gt;&gt; int(True)1&gt;&gt;&gt; int(False)0 当将浮点数转换为整数时，int() 将进行取整，而不是四舍五入。 1234&gt;&gt;&gt; int(98.6)98&gt;&gt;&gt; int(1.0e4)10000 也可以将仅包含数字和正负号的字符串转换为整数： 123456&gt;&gt;&gt; int('99') 99&gt;&gt;&gt; int('-23') -23&gt;&gt;&gt; int('+12') 12 将一个整数转换为整数没有太多意义，这既不会产生任何改变也不会造成任何损失： 12&gt;&gt;&gt; int(12345)12345 如果你试图将一个与数字无关的类型转化为整数，会得到一个异常： 12345678910&gt;&gt;&gt; int('asfd')Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;ValueError: invalid literal for int() with base 10: 'asfd'&gt;&gt;&gt; &gt;&gt;&gt; int('')Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;ValueError: invalid literal for int() with base 10: ''&gt;&gt;&gt; int()可以接受浮点数或由数字组成的字符串，但无法接受包含小数点或指数的字符串： 123456789&gt;&gt;&gt; int('98.6')Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;ValueError: invalid literal for int() with base 10: '98.6'&gt;&gt;&gt; int('1.0e4')Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;ValueError: invalid literal for int() with base 10: '1.0e4'&gt;&gt;&gt; 如果混合使用多种不同的数字类型进行计算，Python 会自动地进行类型转换： 12&gt;&gt;&gt; 4 + 7.011.0 与整数或浮点数混合使用时，布尔型的 False 会被当作 0 或 0.0，Ture 会被当作 1 或 1.0： 1234&gt;&gt;&gt; True + 23&gt;&gt;&gt; False + 5.05.0 一个int型有多大在 Python 2 里，一个 int 型包含 32 位，可以存储从 -2 147 483 648 到 2 147 483 647 的整数。 一个 long 型会占用更多的空间:64 位，可以存储从 -9 223 372 036 854 775 808 到 9 223 372 036 854 775 807 的整数。 到了 Python 3，long 类型已不复存在，而 int 类型变为可以存储任意大小的整数，甚至超 过 64 位。因此，你可以进行像下面一样计算 (10**100 被赋值给名为 googol 的变量，这是 Google 最初的名字，但由于其拼写困难而被现在的名字所取代)： 12345&gt;&gt;&gt;&gt;&gt;&gt; googol = 10**100&gt;&gt;&gt; googol 10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000&gt;&gt;&gt; googol * googol100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000 在许多其他编程语言中，进行类似上面的计算会造成整数溢出，这是因为计算中的数字或 结果需要的存储空间超过了计算机所提供的(例如 32 位或 64 位)。在程序编写中，溢出 会产生许多负面影响。而 Python 在处理超大数计算方面不会产生任何错误，这也是它的一个加分点。 浮点数float使用 float() 函数可以将其他数字类型转换为浮点型。 1234&gt;&gt;&gt; float(True)1.0&gt;&gt;&gt; float(False)0.0 将整数转换为浮点数 1234&gt;&gt;&gt; float(98) 98.0&gt;&gt;&gt; float('99') 99.0 此外，也可以将包含有效浮点数(数字、正负号、小数点、指数及指数的前缀 e)的字符 串转换为真正的浮点型数字： 123456&gt;&gt;&gt; float('98.6') 98.6&gt;&gt;&gt; float('-1.5') -1.5&gt;&gt;&gt; float('1.0e4') 10000.0 浮点数精确到小数点后 15 位。 12&gt;&gt;&gt; 1.12345678901234567890 1.1234567890123457]]></content>
      <categories>
        <category>Python</category>
      </categories>
  </entry>
</search>
