<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Python字符串]]></title>
    <url>%2F2018%2F02%2F05%2FPython%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[使用引号创建将一系列字符包裹在一对单引号或一对双引号中即可创建字符串，就像下面这样： 1234&gt;&gt;&gt; 'Snap' 'Snap'&gt;&gt;&gt; "Crackle" 'Crackle' 交互式解释器输出的字符串永远是用单引号包裹的，但无论使用哪种引号，Python 对字符 串的处理方式都是一样的，没有任何区别。 既然如此，为什么要使用两种引号?这么做的好处是可以创建本身就包含引号的字符串， 而不用使用转义符。可以在双引号包裹的字符串中使用单引号，或者在单引号包裹的字符 串中使用双引号： 1234567&gt;&gt;&gt; "'Nay,' said the naysayer.""'Nay,' said the naysayer."&gt;&gt;&gt; 'The rare double quote in captivity: ".''The rare double quote in captivity: ".'&gt;&gt;&gt; 'A "two by four" is actually 1 1⁄2" × 3 1⁄2".''A "two by four is" actually 1 1⁄2" × 3 1⁄2".'&gt;&gt;&gt; "'There's the man that shot my paw!' cried the limping hound." "'There's the man that shot my paw!' cried the limping hound." 你还可以使用连续三个单引号 &#39;&#39;&#39;，或者三个双引号 &quot;&quot;&quot; 创建字符串： 1234&gt;&gt;&gt; '''Boom!''' 'Boom'&gt;&gt;&gt; """Eek!""" 'Eek!' 三元引号在创建短字符串时没有什么特殊用处。它多用于创建多行字符串： 123456&gt;&gt;&gt; poem = '''There was a Young Lady of Norway,... Who casually sat in a doorway;... When the door squeezed her flat,... She exclaimed, "What of that?"... This courageous Young Lady of Norway.'''&gt;&gt;&gt; 在三元引号包裹的字符串中，每行的换行符以及行首或行末的空格都会被保留： 1234567891011&gt;&gt;&gt; poem2 = '''I do not like thee, Doctor Fell.... The reason why, I cannot tell.... But this I know, and know full well:... I do not like thee, Doctor Fell.... '''&gt;&gt;&gt; print(poem2)I do not like thee, Doctor Fell. The reason why, I cannot tell. But this I know, and know full well: I do not like thee, Doctor Fell.&gt;&gt;&gt; 值得注意的是，print() 函数的输出与交互式解释器的自动响应输出存在一些差异： 12&gt;&gt;&gt; poem2'I do not like thee, Doctor Fell.\n The reason why, I cannot tell.\n But this I know, and know full well:\n I do not like thee, Doctor Fell.\n' print()会把包裹字符串的引号截去，仅输出其实际内容，易于阅读。它还会自动地在各 个输出部分之间添加空格，并在所有输出的最后添加换行符： 12&gt;&gt;&gt; print(99, 'bottles', 'would be enough.') 99 bottles would be enough. 如果你不希望print() 自动添加空格或换行，随后将学会如何避免它们。 最后要指出的是 Python 允许空串的存在，它不包含任何字符且完全合法： 12345678&gt;&gt;&gt; ''''&gt;&gt;&gt; ""''&gt;&gt;&gt; ''''''''&gt;&gt;&gt; """"""'' 为什么会用到空字符串？有些时候你想要创建的字符串可能源自另一字符串的内容，这时 需要先创建一个空白的模板，也就是一个空字符串。 123456&gt;&gt;&gt; bottles = 99&gt;&gt;&gt; base = ''&gt;&gt;&gt; base += 'current inventory: ' &gt;&gt;&gt; base += str(bottles)&gt;&gt;&gt; base'current inventory: 99' 字符串是一个序列字符串是由字符组成的序列。你可以用括号运算符一次访问一个字符: 12&gt;&gt;&gt; fruit = &apos;banana&apos;&gt;&gt;&gt; letter = fruit[1] 使用str()进行类型转换使用 str() 可以将其他 Python 数据类型转换为字符串： 123456&gt;&gt;&gt; str(98.6) '98.6'&gt;&gt;&gt; str(1.0e4) '10000.0'&gt;&gt;&gt; str(True) 'True' 当你调用 print() 函数或者进行字符串差值(string interpolation)时，Python 内部会自动 使用 str() 将非字符串对象转换为字符串。 使用\转义Python 允许你对某些字符进行转义操作，以此来实现一些难以单纯用字符描述的效果。在 字符的前面添加反斜线符号\ 会使该字符的意义发生改变。最常见的转义符是 \n，它代表 换行符，便于你在一行内创建多行字符串。 123456&gt;&gt;&gt; palindrome = 'A man,\nA plan,\nA canal:\nPanama.' &gt;&gt;&gt; print(palindrome)A man,A plan,A canal:Panama. 转义符 \t(tab 制表符)常用于对齐文本： 123456&gt;&gt;&gt; print('\tabc') abc&gt;&gt;&gt; print('a\tbc') a bc&gt;&gt;&gt; print('ab\tc') ab c 有时你可能还会用到 \&#39; 和 \&quot; 来表示单、双引号，尤其当该字符串由相同类型的引号包裹时: 1234567&gt;&gt;&gt; testimony = "\"I did nothing!\" he said. \"Not that either! Or the other thing.\""&gt;&gt;&gt; print(testimony)"I did nothing!" he said. "Not that either! Or the other thing."&gt;&gt;&gt; fact = "The world's largest rubber duck was 54'2\" by 65'7\" by 105'"&gt;&gt;&gt; print(fact)The world's largest rubber duck was 54'2" by 65'7" by 105' 如果你需要输出一个反斜线字符，连续输入两个反斜线即可: 123&gt;&gt;&gt; speech = 'Today we honor our friend, the backslash: \\.' &gt;&gt;&gt; print(speech)Today we honor our friend, the backslash: \. 使用+拼接在 Python 中，你可以使用 + 将多个字符串或字符串变量拼接起来，就像下面这样: 12&gt;&gt;&gt; &apos;Release the kraken! &apos; + &apos;At once!&apos; &apos;Release the kraken! At once!&apos; 也可以直接将一个字面字符串(非字符串变量)放到另一个的后面直接实现拼接: 12&gt;&gt;&gt; &quot;My word! &quot; &quot;A gentleman caller!&quot;&apos;My word! A gentleman caller!&apos; 进行字符串拼接时，Python 并不会自动为你添加空格，需要显示定义。但当我们调用print() 进行打印时，Python 会在各个参数之间自动添加空格并在结尾添加换行符: 1234567&gt;&gt;&gt; a = &apos;Duck.&apos;&gt;&gt;&gt; b = a&gt;&gt;&gt; c = &apos;Grey Duck!&apos; &gt;&gt;&gt; a + b + c &apos;Duck.Duck.Grey Duck!&apos; &gt;&gt;&gt; print(a, b, c) Duck. Duck. Grey Duck! 使用*复制使用 * 可以进行字符串复制。 1234&gt;&gt;&gt; start = &apos;Na &apos; * 4 + &apos;\n&apos;&gt;&gt;&gt; middle = &apos;Hey &apos; * 3 + &apos;\n&apos;&gt;&gt;&gt; end = &apos;Goodbye.&apos;&gt;&gt;&gt; print(start + start + middle + end) 使用[]提取字符在字符串名后面添加 []，并在括号里指定偏移量可以提取该位置的单个字符。第一个字符 (最左侧)的偏移量为0，下一个是1，以此类推。最后一个字符(最右侧)的偏移量也可以用 -1 表示，这样就不必从头数到尾。偏移量从右到左紧接着为 -2、-3，以此类推。 12345678910111213&gt;&gt;&gt; letters = &apos;abcdefghijklmnopqrstuvwxyz&apos; &gt;&gt;&gt; letters[0]&apos;a&apos;&gt;&gt;&gt; letters[1]&apos;b&apos;&gt;&gt;&gt; letters[-1] &apos;z&apos;&gt;&gt;&gt; letters[-2] &apos;y&apos;&gt;&gt;&gt; letters[25] &apos;z&apos;&gt;&gt;&gt; letters[5] &apos;f&apos; 字符串是不可变的由于字符串是不可变的，因此你无法直接插入字符或改变指定位置的字符 12345&gt;&gt;&gt; name = &apos;Henny&apos;&gt;&gt;&gt; naume[0] = &apos;P&apos;Traceback (most recent call last):File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;TypeError: &apos;str&apos; object does not support item assignment 为了改变字符串，我们需要组合使用一些字符串函数，例如replace()，以及分片操作: 12345&gt;&gt;&gt; name = &apos;Henny&apos;&gt;&gt;&gt; name.replace(&apos;H&apos;, &apos;P&apos;) &apos;Penny&apos;&gt;&gt;&gt; &apos;P&apos; + name[1:]&apos;Penny&apos; 使用[start:end:step]分片分片操作(slice)可以从一个字符串中抽取子字符串(字符串的一部分)。 我们使用一对方 括号、起始偏移量 start、终止偏移量 end 以及可选的步长 step 来定义一个分片。其中一 些可以省略。 分片得到的子串包含从 start 开始到 end 之前的全部字符。 [:] 提取从开头到结尾的整个字符串 [start:] 从 start 提取到结尾 [:end] 从开头提取到 end - 1 [start:end] 从 start 提取到 end - 1 [start:end:step] 从 start 提取到 end - 1，每 step 个字符提取一个 偏移量从左至右从 0、1 开始，依次增加； 从右至左从-1、-2 开始，依次减 小。 如果省略 start，分片会默认使用偏移量 0(开头)； 如果省略 end，分片会默认使用 偏移量 -1(结尾)。 我们来创建一个由小写字母组成的字符串: 1&gt;&gt;&gt; letters = &apos;abcdefghijklmnopqrstuvwxyz&apos; 仅仅使用: 分片等价于使用 0 : -1(也就是提取整个字符串): 12&gt;&gt;&gt; letters[:] &apos;abcdefghijklmnopqrstuvwxyz&apos; 下面是一个从偏移量 20 提取到字符串结尾的例子: 12&gt;&gt;&gt; letters[20:]&apos;uvwxyz&apos; 下一个例子提取了偏移量从 12 到 14 的字符: 12&gt;&gt;&gt; letters[12:15] &apos;mno&apos; 提取最后三个字符: 12&gt;&gt;&gt; letters[-3:] &apos;xyz&apos; 下面一个例子提取了从偏移量为 18 的字符到倒数第 4 个字符。 注意与上一个例子的区别: 当偏移量 -3 作为开始位置时，将获得字符 x;而当它作为终止位置时，分片实际上会在偏 移量 -4 处停止，也就是提取到字符 w: 12&gt;&gt;&gt; letters[18:-3] &apos;stuvw&apos; 接下来，试着提取从倒数第 6 个字符到倒数第 3 个字符: 12&gt;&gt;&gt; letters[-6:-2]&apos;uvwx&apos; 如果你需要的步长不是默认的 1，可以在第二个冒号后面进行指定。 从开头提取到结尾，步长设为 7: 12&gt;&gt;&gt; letters[::7] &apos;ahov&apos; 从偏移量 4 提取到偏移量 19，步长设为 3: 12&gt;&gt;&gt; letters[4:20:3]&apos;ehknqt&apos; 从偏移量 19 提取到结尾，步长设为 4: 12&gt;&gt;&gt; letters[19::4] &apos;tx&apos; 从开头提取到偏移量 20，步长设为 5: 12&gt;&gt;&gt; letters[:21:5]&apos;afkpu&apos; 记住，分片中 end 的偏移量需要比实际提取的最后一个字符的偏移量多 1。 如果指定的步长为负数，机智的 Python 还会从右到左反 向进行提取操作。 下面这个例子便从右到左以步长为 1 进行提取: 12&gt;&gt;&gt; letters[-1::-1] &apos;zyxwvutsrqponmlkjihgfedcba&apos; 事实上，你可以将上面的例子简化为下面这种形式，结果完全一致: 12&gt;&gt;&gt; letters[::-1] &apos;zyxwvutsrqponmlkjihgfedcba&apos; 分片操作对于无效偏移量的容忍程度要远大于单字符提取操作。在分片中，小于起始位置的 偏移量会被当作 0，大于终止位置的偏移量会被当作 -1。 提取倒数 50 个字符: 12&gt;&gt;&gt; letters[-50:]&apos;abcdefghijklmnopqrstuvwxyz&apos; 提取从倒数第 51 到倒数第 50 个字符: 12&gt;&gt;&gt; letters[-51:-50]&apos;&apos; 从开头提取到偏移量为 69 的字符: 12&gt;&gt;&gt; letters[:70]&apos;abcdefghijklmnopqrstuvwxyz&apos; 从偏移量为 70 的字符提取到偏移量为 71 的字符: 12&gt;&gt;&gt; letters[70:71]&apos;&apos; 使用len()获得长度len() 函数可用于计算字符串包含的字符数: 12345&gt;&gt;&gt; len(letters)26&gt;&gt;&gt; empty = &quot;&quot;&gt;&gt;&gt; len(empty)0 也可以对其他的序列类型使用 len() 使用split()分割与广义函数len() 不同，有些函数只适用于字符串类型。使用内置的字符串函数 split()可以基于分隔符将字符串分割成由若干子串组成的列表。 123&gt;&gt;&gt; todos = &apos;get gloves,get mask,give cat vitamins,call ambulance&apos; &gt;&gt;&gt; todos.split(&apos;,&apos;)[&apos;get gloves&apos;, &apos;get mask&apos;, &apos;give cat vitamins&apos;, &apos;call ambulance&apos;] 如 果不指定分隔符，那么 split() 将默认使用空白字符——换行符、空格、制表符。 12&gt;&gt;&gt; todos.split()[&apos;get&apos;, &apos;gloves,get&apos;, &apos;mask,give&apos;, &apos;cat&apos;, &apos;vitamins,call&apos;, &apos;ambulance&apos;] 使用join()合并join() 函数与 split()函数正好相反：它将包含若干子串的列表分 解，并将这些子串合成一个完整的大的字符串。 join()的调用顺序看起来有点别扭，与 split() 相反，你需要首先指定粘合用的字符串，然后再指定需要合并的列表：string. join(list)。 因此，为了将列表 lines 中的多个子串合并成完整的字符串，我们应该使用语 句：&#39;\n&#39;.join(lines)。 下面的例子将列表中的名字通过逗号及空格粘合在一起: 1234&gt;&gt;&gt; crypto_list = [&apos;Yeti&apos;, &apos;Bigfoot&apos;, &apos;Loch Ness Monster&apos;]&gt;&gt;&gt; crypto_string = &apos;, &apos;.join(crypto_list)&gt;&gt;&gt; print(&apos;Found and signing book deals:&apos;, crypto_string) Found and signing book deals: Yeti, Bigfoot, Loch Ness Monster 其他常用字符串相关函数我们的测试对象是下面的字符串 123456&gt;&gt;&gt; poem = &apos;&apos;&apos;All that doth flow we cannot liquid nameOr else would fire and water be the same;But that is liquid which is moist and wetFire that property can never get.Then &apos;tis not cold that doth the fire put out But &apos;tis the wet that makes it die, no doubt.&apos;&apos;&apos; 这首诗有多少个字符呢?(计入空格和换行符。) 12&gt;&gt;&gt; len(poem)250 这首诗是不是以 All 开头呢? 12&gt;&gt;&gt; poem.startswith(&apos;All&apos;)True 它是否以 That’s all, folks!? 结尾? 12&gt;&gt;&gt; poem.endswith(&apos;That\&apos;s all, folks!&apos;) False 查一查诗中第一次出现单词 the 的位置(偏移量): 123&gt;&gt;&gt; word = &apos;the&apos; &gt;&gt;&gt; poem.find(word) 73 以及最后一次出现 the 的偏移量 : 12&gt;&gt;&gt; poem.rfind(word)214 the 在这首诗中出现了多少次? 12&gt;&gt;&gt; poem.count(word)3 诗中出现的所有字符都是字母或数字吗? 12&gt;&gt;&gt; poem.isalnum()False 并非如此，诗中还包括标点符号。 大小写与对齐方式我们的测试字符串如下所示: 1&gt;&gt;&gt; setup = &apos;a duck goes into a bar...&apos; 将字符串收尾的. 都删除掉: 12&gt;&gt;&gt; setup.strip(&apos;.&apos;)&apos;a duck goes into a bar&apos; 由于字符串是不可变的，上面这些例子实际上没有一个对 setup 真正做了修 改。它们都仅仅是获取了 setup 的值，进行某些操作后将操作结果赋值给了 另一个新的字符串而已。 让字符串首字母变成大写: 12&gt;&gt;&gt; setup.capitalize()&apos;A duck goes into a bar...&apos; 让所有单词的开头字母变成大写: 12&gt;&gt;&gt; setup.title()&apos;A Duck Goes Into A Bar...&apos; 让所有字母都变成大写: 12&gt;&gt;&gt; setup.upper()&apos;A DUCK GOES INTO A BAR...&apos; 将所有字母转换成小写: 12&gt;&gt;&gt; setup.lower()&apos;a duck goes into a bar...&apos; 将所有字母的大小写转换: 12&gt;&gt;&gt; setup.swapcase()&apos;a DUCK GOES INTO A BAR...&apos; 再来看看与格式排版相关的函数。这里，我们假设例子中的字符串被排版在指定长度(这 里是 30 个字符)的空间里。 在 30 个字符位居中: 12&gt;&gt;&gt; setup.center(30)&apos; a duck goes into a bar... &apos; 左对齐: 12&gt;&gt;&gt; setup.ljust(30)&apos;a duck goes into a bar... &apos; 右对齐: 12&gt;&gt;&gt; setup.rjust(30)&apos; a duck goes into a bar...&apos; 使用replace()替换使用 replace() 函数可以进行简单的子串替换。 你需要传入的参数包括：需要被替换的子 串，用于替换的新子串，以及需要替换多少处。最后一个参数如果省略则默认只替换第一次出现的位置: 12&gt;&gt;&gt; setup.replace(&apos;duck&apos;, &apos;marmoset&apos;) &apos;a marmoset goes into a bar...&apos; 修改最多 100 处： 12&gt;&gt;&gt; setup.replace(&apos;a &apos;, &apos;a famous &apos;, 100)&apos;a famous duck goes into a famous bar...&apos; 当你准确地知道想要替换的子串是什么样子时，replace() 是个非常不错的选择。但使用 时一定要小心! 在上面第二个例子中，如果我们粗心地把需要替换的子串写成了单个字符 的 ‘a’ 而不是两个字符的 ‘a ‘(a 后面跟着一个空格)的话，会错误地将所有单词中出现 的 a 也一并替换了: 12&gt;&gt;&gt; setup.replace(&apos;a&apos;, &apos;a famous&apos;, 100)&apos;a famous duck goes into a famous ba famousr...&apos;]]></content>
      <categories>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Python学习笔记之变量和内置数据类型]]></title>
    <url>%2F2018%2F02%2F04%2FPython%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%8F%98%E9%87%8F%E5%92%8C%E5%86%85%E7%BD%AE%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[Python 里一切都是以对象(object)的形式存在的。 变量变量的命名规则 变量名只能包含字母、数字和下划线。 变量名不能以数字开头。 不能使用以下保留的关键字作为变量名： 1234567False class finally is returnNone continue for lambda tryTrue def from nonlocal whileand del global not withas elif if or yieldassert else import passbreak except in raise 内置数据类型在 Python 中您并不需要声明变量的数据类型。Python 根据每 个变量的初始赋值情况分析其类型，并在内部对其进行跟踪。 type()函数查看对象类型在 Python 中，如果想知道一个对象(例如一个变量或者一个字面值)的类型，可以使用语 句：type( thing )。 12345678910&gt;&gt;&gt; type(a) &lt;class 'int'&gt; &gt;&gt;&gt; type(b) &lt;class 'int'&gt; &gt;&gt;&gt; type(58) &lt;class 'int'&gt; &gt;&gt;&gt; type(99.9)&lt;class 'float'&gt; &gt;&gt;&gt; type('abc') &lt;class 'str'&gt; isinstance() 函数判断某个值或变量是否为给定某个类型。12&gt;&gt;&gt; isinstance(1, int) True 布尔型Python 有两个被巧妙地命名为 True 和 False 的常量，可用于对布尔类型的直接赋值。 数值型Python 本身支持整数(比如 5 和 1000000000)以及浮点数(比如 3.1416、14.99 和 1.87e4)。你可以对这些数字进行下表中的计算。 运算符 描述 示例 运算结果 + 加法 5 + 8 13 - 减法 90 – 10 80 * 乘法 4 * 7 28 / 除法 7 / 2 3.5 // 取整除（返回商的整数部分） 7 // 2 3 % 模（求余） 7 % 3 1 ** 幂 3 ** 4 81 整数int任何仅含数字的序列在 Python 中都被认为是整数: 12&gt;&gt;&gt; 55 你可以单独使用数字零(0): 12&gt;&gt;&gt; 00 但不能把它作为前缀放在其他数字前面: 123456&gt;&gt;&gt; 05 File "&lt;stdin&gt;", line 1 05 ^SyntaxError: invalid token&gt;&gt;&gt; 一个数字序列定义了一个正整数。你也可以显式地在前面加上正号 +，这不会使数字发生 任何改变: 1234&gt;&gt;&gt; 123123&gt;&gt;&gt; +123123 在数字前添加负号 - 可以定义一个负数: 12&gt;&gt;&gt; -123-123 除法运算比较有意思，可能与你预期的有些出入，因为 Python 里有两种除法: / 用来执行浮点除法(十进制小数) // 用来执行整数除法(整除) 与其他语言不同，在 Python 中即使运算对象是两个整数，使用 / 仍会得到浮点型的结果: 12&gt;&gt;&gt; 9 / 5 1.8 使用整除运算得到的是一个整数，余数会被截去: 12&gt;&gt;&gt; 9 // 5 1 如果除数为 0，任何一种除法运算都会产生 Python 异常: 123456789&gt;&gt;&gt; 5 / 0Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;ZeroDivisionError: division by zero&gt;&gt;&gt; 7 // 0Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;ZeroDivisionError: integer division or modulo by zero&gt;&gt;&gt; Python 还支持以下写法 1234&gt;&gt;&gt; a = 95&gt;&gt;&gt; a -= 3&gt;&gt;&gt; a92 使用下面的方法可以同时得到余数和商: 12&gt;&gt;&gt; divmod(9,5)(1, 4) 上面的代码出现了一些你没见过的新东西:一个叫作 divmod 的函数。这个函数接受了两个 整数:9 和 5，并返回了一个包含两个元素的结果，我们称这种结构为元组(tuple)。 运算优先级建议总是使用括号来保证运算顺序与我们期望的一致: 12&gt;&gt;&gt; 2 + (3 * 4)14 基数在 Python 中，整数默认使用十进制数，除非你在数字前添加前缀，显式地指 定使用其他基数(base)。 在 Python 中，除十进制外你还可以使用其他三种进制的数字: 0b 或 0B 代表二进制(以 2 为底) 0o 或 0O 代表八进制(以 8 为底) 0x 或 0X 代表十六进制(以 16 为底) Python 解释器会打印出它们对应的十进制整数： 123456&gt;&gt;&gt; 0b102&gt;&gt;&gt; 0o108&gt;&gt;&gt; 0x1016 使用int()函数转换为整型我们可以方便地使用 int() 函数将其他的 Python 数据类型转换为整型。它会保留传入数据的整数部分并舍去小数部分。 Python 里最简单的数据类型是布尔型，它只有两个可选值：True 和 False。当转换为整数时，它们分别代表 1 和 0： 1234&gt;&gt;&gt; int(True)1&gt;&gt;&gt; int(False)0 当将浮点数转换为整数时，int() 将进行取整，而不是四舍五入。 1234&gt;&gt;&gt; int(98.6)98&gt;&gt;&gt; int(1.0e4)10000 也可以将仅包含数字和正负号的字符串转换为整数： 123456&gt;&gt;&gt; int('99') 99&gt;&gt;&gt; int('-23') -23&gt;&gt;&gt; int('+12') 12 将一个整数转换为整数没有太多意义，这既不会产生任何改变也不会造成任何损失： 12&gt;&gt;&gt; int(12345)12345 如果你试图将一个与数字无关的类型转化为整数，会得到一个异常： 12345678910&gt;&gt;&gt; int('asfd')Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;ValueError: invalid literal for int() with base 10: 'asfd'&gt;&gt;&gt; &gt;&gt;&gt; int('')Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;ValueError: invalid literal for int() with base 10: ''&gt;&gt;&gt; int()可以接受浮点数或由数字组成的字符串，但无法接受包含小数点或指数的字符串： 123456789&gt;&gt;&gt; int('98.6')Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;ValueError: invalid literal for int() with base 10: '98.6'&gt;&gt;&gt; int('1.0e4')Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;ValueError: invalid literal for int() with base 10: '1.0e4'&gt;&gt;&gt; 如果混合使用多种不同的数字类型进行计算，Python 会自动地进行类型转换： 12&gt;&gt;&gt; 4 + 7.011.0 与整数或浮点数混合使用时，布尔型的 False 会被当作 0 或 0.0，Ture 会被当作 1 或 1.0： 1234&gt;&gt;&gt; True + 23&gt;&gt;&gt; False + 5.05.0 一个int型有多大在 Python 2 里，一个 int 型包含 32 位，可以存储从 -2 147 483 648 到 2 147 483 647 的整数。 一个 long 型会占用更多的空间:64 位，可以存储从 -9 223 372 036 854 775 808 到 9 223 372 036 854 775 807 的整数。 到了 Python 3，long 类型已不复存在，而 int 类型变为可以存储任意大小的整数，甚至超 过 64 位。因此，你可以进行像下面一样计算 (10**100 被赋值给名为 googol 的变量，这是 Google 最初的名字，但由于其拼写困难而被现在的名字所取代)： 12345&gt;&gt;&gt;&gt;&gt;&gt; googol = 10**100&gt;&gt;&gt; googol 10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000&gt;&gt;&gt; googol * googol100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000 在许多其他编程语言中，进行类似上面的计算会造成整数溢出，这是因为计算中的数字或 结果需要的存储空间超过了计算机所提供的(例如 32 位或 64 位)。在程序编写中，溢出 会产生许多负面影响。而 Python 在处理超大数计算方面不会产生任何错误，这也是它的一个加分点。 浮点数float使用 float() 函数可以将其他数字类型转换为浮点型。 1234&gt;&gt;&gt; float(True)1.0&gt;&gt;&gt; float(False)0.0 将整数转换为浮点数 1234&gt;&gt;&gt; float(98) 98.0&gt;&gt;&gt; float('99') 99.0 此外，也可以将包含有效浮点数(数字、正负号、小数点、指数及指数的前缀 e)的字符 串转换为真正的浮点型数字： 123456&gt;&gt;&gt; float('98.6') 98.6&gt;&gt;&gt; float('-1.5') -1.5&gt;&gt;&gt; float('1.0e4') 10000.0 浮点数精确到小数点后 15 位。 12&gt;&gt;&gt; 1.12345678901234567890 1.1234567890123457]]></content>
      <categories>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Markdown 语法参考]]></title>
    <url>%2F2018%2F02%2F02%2FMarkdown%20Demo%2F</url>
    <content type="text"><![CDATA[Markdown For TyporaOverviewMarkdown is created by Daring Fireball, the original guideline is here. Its syntax, however, varies between different parsers or editors. Typora is using GitHub Flavored Markdown. Please note that HTML fragments in markdown source will be recognized but not parsed or rendered. Also, there may be small reformatting on the original markdown source code after saving. Outline Block ElementsParagraph and line breaksA paragraph is simply one or more consecutive lines of text. In markdown source code, paragraphs are separated by more than one blank lines. In Typora, you only need to press Return to create a new paragraph. Press Shift + Return to create a single line break. However, most markdown parser will ignore single line break, to make other markdown parsers recognize your line break, you can leave two whitespace at the end of the line, or insert &lt;br/&gt;. HeadersHeaders use 1-6 hash characters at the start of the line, corresponding to header levels 1-6. For example: 12345# This is an H1## This is an H2###### This is an H6 In typora, input ‘#’s followed by title content, and press Return key will create a header. BlockquotesMarkdown uses email-style &gt; characters for block quoting. They are presented as: 1234567&gt; This is a blockquote with two paragraphs. This is first paragraph.&gt;&gt; This is second pragraph.Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.&gt; This is another blockquote with one paragraph. There is three empty line to seperate two blockquote. In typora, just input ‘&gt;’ followed by quote contents a block quote is generated. Typora will insert proper ‘&gt;’ or line break for you. Block quote inside anther block quote is allowed by adding additional levels of ‘&gt;’. ListsInput * list item 1 will create an un-ordered list, the * symbol can be replace with + or -. Input 1. list item 1 will create an ordered list, their markdown source code is like: 123456789## un-ordered list* Red* Green* Blue## ordered list1. Red2. Green3. Blue Task ListTask lists are lists with items marked as either [ ] or [x] (incomplete or complete). For example: 12345- [ ] a task list item- [ ] list syntax required- [ ] normal **formatting**, @mentions, #1234 refs- [ ] incomplete- [x] completed You can change the complete/incomplete state by click the checkbox before the item. (Fenced) Code BlocksTypora only support fences in Github Flavored Markdown. Original code blocks in markdown is not supported. Using fences is easy: Input ``` and press return. Add an optional language identifier after ``` and we’ll run it through syntax highlighting: Here’s an example:123function test() &#123; console.log("notice the blank line before this function?");&#125; syntax highlighting:123require 'redcarpet'markdown = Redcarpet.new("Hello World!")puts markdown.to_html TablesInput | First Header | Second Header | and press return key will create a table with two column. After table is created, focus on that table will pop up a toolbar for table, where you can resize, align, or delete table. You can also use context menu to copy and add/delete column/row. Following descriptions can be skipped, as markdown source code for tables are generated by typora automatically. In markdown source code, they look like: 1234| First Header | Second Header || ------------- | ------------- || Content Cell | Content Cell || Content Cell | Content Cell | First Header Second Header Content Cell Content Cell Content Cell Content Cell You can also include inline Markdown such as links, bold, italics, or strikethrough. Finally, by including colons : within the header row, you can define text to be left-aligned, right-aligned, or center-aligned: 12345| Left-Aligned | Center Aligned | Right Aligned || :------------ |:---------------:| -----:|| col 3 is | some wordy text | $1600 || col 2 is | centered | $12 || zebra stripes | are neat | $1 | Left-Aligned Center Aligned Right Aligned col 3 is some wordy text $1600 col 2 is centered $12 zebra stripes are neat $1 A colon on the left-most side indicates a left-aligned column; a colon on the right-most side indicates a right-aligned column; a colon on both sides indicates a center-aligned column. Horizontal RulesInput *** or --- on a blank line and press return will draw a horizontal line. YAML Front MatterTypora support YAML Front Matter now. Input --- at the top of the article and then press Enter will introduce one. Or insert one metadata block from the menu. Diagrams (Sequence, Flowchart and Mermaid)Typora supports, sequence, flowchart and mermaid, after this feature is enabled from preference panel. See this document for detail. Span ElementsSpan elements will be parsed and rendered right after your typing. Moving cursor in middle of those span elements will expand those elements into markdown source. Following will explain the syntax of those span element. LinksMarkdown supports two style of links: inline and reference. In both styles, the link text is delimited by [square brackets]. To create an inline link, use a set of regular parentheses immediately after the link text’s closing square bracket. Inside the parentheses, put the URL where you want the link to point, along with an optional title for the link, surrounded in quotes. For example: 123This is [an example](http://example.com/ "Title") inline link.[This link](http://example.net/) has no title attribute. will produce: This is an example inline link. (&lt;p&gt;This is &lt;a href=&quot;http://example.com/&quot; title=&quot;Title&quot;&gt;) This link has no title attribute. (&lt;p&gt;&lt;a href=&quot;http://example.net/&quot;&gt;This link&lt;/a&gt; has no) Internal LinksYou can set the href to headers, which will create a bookmark that allow you to jump to that section after clicking. For example: Command(on Windows: Ctrl) + Click This link will jump to header Block Elements. To see how to write that, please move cursor or click that link with ⌘ key pressed to expand the element into markdown source. Reference LinksReference-style links use a second set of square brackets, inside which you place a label of your choosing to identify the link: 12345This is [an example][id] reference-style link.Then, anywhere in the document, you define your link label like this, on a line by itself:[id]: http://example.com/ "Optional Title Here" In typora, they will be rendered like: This is an example reference-style link. The implicit link name shortcut allows you to omit the name of the link, in which case the link text itself is used as the name. Just use an empty set of square brackets — e.g., to link the word “Google” to the google.com web site, you could simply write: 1234[Google][]And then define the link:[Google]: http://google.com/ In typora click link will expand it for editing, command+click will open the hyperlink in web browser. URLsTypora allows you to insert urls as links, wrapped by &lt;brackets&gt;. &lt;i@typora.io&gt; becomes &#x69;&#64;&#x74;&#121;&#x70;&#x6f;&#x72;&#97;&#x2e;&#105;&#111;. Typora will aslo auto link standard URLs. e.g: www.google.com. ImagesImage looks similar with links, but it requires an additional ! char before the start of link. Image syntax looks like this: 123![Alt text](/path/to/img.jpg)![Alt text](/path/to/img.jpg "Optional title") You are able to use drag &amp; drop to insert image from image file or we browser. And modify the markdown source code by clicking on the image. Relative path will be used if image is in same directory or sub-directory with current editing document when drag &amp; drop. For more tips on images, please read http://support.typora.io//Images/ EmphasisMarkdown treats asterisks (*) and underscores (_) as indicators of emphasis. Text wrapped with one * or _ will be wrapped with an HTML &lt;em&gt; tag. E.g: 123*single asterisks*_single underscores_ output: single asterisks single underscores GFM will ignores underscores in words, which is commonly used in code and names, like this: wow_great_stuff do_this_and_do_that_and_another_thing. To produce a literal asterisk or underscore at a position where it would otherwise be used as an emphasis delimiter, you can backslash escape it: 1\*this text is surrounded by literal asterisks\* Typora recommends to use * symbol. Strongdouble *’s or _’s will be wrapped with an HTML &lt;strong&gt; tag, e.g: 123**double asterisks**__double underscores__ output: double asterisks double underscores Typora recommends to use ** symbol. CodeTo indicate a span of code, wrap it with backtick quotes (`). Unlike a pre-formatted code block, a code span indicates code within a normal paragraph. For example: 1Use the `printf()` function. will produce: Use the printf() function. StrikethroughGFM adds syntax to create strikethrough text, which is missing from standard Markdown. ~~Mistaken text.~~ becomes Mistaken text. UnderlineUnderline is powered by raw HTML. &lt;u&gt;Underline&lt;/u&gt; becomes Underline. Emoji :happy:Input emoji with syntax :smile:. User can trigger auto-complete suggestions for emoji by pressing ESC key, or trigger it automatically after enable it on preference panel. Also, input UTF8 emoji char directly from Edit -&gt; Emoji &amp; Symbols from menu bar is also supported. HTMLTypora cannot render html fragments. But typora can parse and render very limited HTML fragments, as an extension of Markdown, including: Underline: &lt;u&gt;underline&lt;/u&gt; Image: &lt;img src=&quot;http://www.w3.org/html/logo/img/mark-word-icon.png&quot; width=&quot;200px&quot; /&gt; (And width, height attribute in HTML tag, and width, height, zoom style in style attribute will be applied.) Comments: &lt;!-- This is some comments --&gt; Hyperlink: &lt;a href=&quot;http://typora.io&quot; target=&quot;_blank&quot;&gt;link&lt;/a&gt;. Most of their attributes, styles, or classes will be ignored. For other tags, typora will render them as raw HTML snippets. But those HTML will be exported on print or export. Inline MathTo use this feature, first, please enable it in Preference Panel -&gt; Markdown Tab. Then use $ to wrap TeX command, for example: $\lim_{x \to \infty} \exp(-x) = 0$ will be rendered as LaTeX command. To trigger inline preview for inline math: input “$”, then press ESC key, then input TeX command, a preview tooltip will be visible like below: SubscriptTo use this feature, first, please enable it in Preference Panel -&gt; Markdown Tab. Then use ~ to wrap subscript content, for example: H~2~O, X~long\ text~/ SuperscriptTo use this feature, first, please enable it in Preference Panel -&gt; Markdown Tab. Then use ^ to wrap superscript content, for example: X^2^. HighlightTo use this feature, first, please enable it in Preference Panel -&gt; Markdown Tab. Then use == to wrap superscript content, for example: ==highlight==.]]></content>
      <categories>
        <category>MISCELLANEOUS</category>
      </categories>
      <tags>
        <tag>md</tag>
      </tags>
  </entry>
</search>
