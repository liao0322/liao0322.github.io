<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Python 列表和元组]]></title>
    <url>%2F2018%2F02%2F06%2FPython%E5%88%97%E8%A1%A8%E5%92%8C%E5%85%83%E7%BB%84%2F</url>
    <content type="text"><![CDATA[除字符串外，Python 还有另外两种序列结构：元组和列表。它们都可以包含零个或多个元 素。与字符串不同的是，元组和列表并不要求所含元素的种类相同，每个元素都可以是任 何 Python 类型的对象。 为什么 Python 需要同时设定列表和元组这两种序列呢?这是因为元组是不可变的，当你给 元组赋值时，这些值便被固定在了元组里，再也无法修改。然而，列表却是可变的，这意 味着可以随意地插入或删除其中的元素。 使用[]或list()创建列表列表可以由零个或多个元素组成，元素之间用逗号分开，整个列表被方括号所包裹： 1234&gt;&gt;&gt; empty_list = [ ]&gt;&gt;&gt; weekdays = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday'] &gt;&gt;&gt; big_birds = ['emu', 'ostrich', 'cassowary']&gt;&gt;&gt; first_names = ['Graham', 'John', 'Terry', 'Terry', 'Michael'] 也可以使用 list() 函数来创建一个空列表 123&gt;&gt;&gt; another_empty_list = list()&gt;&gt;&gt; another_empty_list[] 上面的例子中，只有 weekdays 列表充分利用了列表的顺序性。 first_names 则展示了列表 中的值允许重复这一性质。 如果你仅仅想要记录一些互不相同的值，而不在乎它们之间的顺序关系，集 合(set)会是一个更好的选择。在上面的例子中，big_birds 就更适合存储 在一个集合中。 使用list()将其他数据类型转换成列表Python 的 list() 函数可以将其他数据类型转换成列表类型。 12&gt;&gt;&gt; list('cat') ['c', 'a', 't'] 接下来的例子将一个元组转换成了列表: 123&gt;&gt;&gt; a_tuple = ('ready', 'fire', 'aim') &gt;&gt;&gt; list(a_tuple)['ready', 'fire', 'aim'] 使用 split() 可以依据分隔符将字符串切割成由若干子串组成的列表: 123&gt;&gt;&gt; birthday = '1/6/1952' &gt;&gt;&gt; birthday.split('/') ['1', '6', '1952'] 如果待分割的字符串中包含连续的分隔符，那么在返回的列表中会出现空串元素: 123&gt;&gt;&gt; splitme = 'a/b//c/d///e'&gt;&gt;&gt; splitme.split('/')['a', 'b', '', 'c', 'd', '', '', 'e'] 如果把上面例子中的分隔符改成 // 则会得到如下结果: 1234&gt;&gt;&gt; splitme = 'a/b//c/d///e' &gt;&gt;&gt; splitme.split('//')&gt;&gt;&gt;['a/b', 'c/d', '/e'] 使用[offset]获取元素通过偏移量可以从列表中提取对应位置的元素: 1234567&gt;&gt;&gt; marxes = ['Groucho', 'Chico', 'Harpo'] &gt;&gt;&gt; marxes[0]'Groucho'&gt;&gt;&gt; marxes[1]'Chico'&gt;&gt;&gt; marxes[2] 'Harpo' 负偏移量代表从尾部开始计数: 1234567&gt;&gt;&gt; marxes[-1] 'Harpo'&gt;&gt;&gt; marxes[-2] 'Chico'&gt;&gt;&gt; marxes[-3] 'Groucho'&gt;&gt;&gt; 包含列表的列表列表可以包含各种类型的元素，包括其他列表 1234&gt;&gt;&gt; small_birds = ['hummingbird', 'finch']&gt;&gt;&gt; extinct_birds = ['dodo', 'passenger pigeon', 'Norwegian Blue'] &gt;&gt;&gt; carol_birds = [3, 'French hens', 2, 'turtledoves']&gt;&gt;&gt; all_birds = [small_birds, extinct_birds, 'macaw', carol_birds] all_birds 这个列表的结构是什么样子的? 12&gt;&gt;&gt; all_birds[['hummingbird', 'finch'], ['dodo', 'passenger pigeon', 'Norwegian Blue'], 'macaw', [3, 'French hens', 2, 'turtledoves']] 使用[offset]修改元素就像可以通过偏移量访问某元素一样，你也可以通过赋值对它进行修改: 1234&gt;&gt;&gt; marxes = ['Groucho', 'Chico', 'Harpo'] &gt;&gt;&gt; marxes[2] = 'Wanda'&gt;&gt;&gt; marxes['Groucho', 'Chico', 'Wanda'] 指定范围并使用切片提取元素你可以使用切片提取列表的一个子序列: 123&gt;&gt;&gt; marxes = ['Groucho', 'Chico,' 'Harpo'] &gt;&gt;&gt; marxes[0:2]['Groucho', 'Chico'] 列表的切片仍然是一个列表。 与字符串一样，列表的切片也可以设定除 1 以外的步长。下面的例子从列表的开头开始每2 个提取一个元素: 12&gt;&gt;&gt; marxes[::2]['Groucho', 'Harpo'] 再试试从尾部开始提取，步长仍为 2: 12&gt;&gt;&gt; marxes[::-2] ['Harpo', 'Groucho'] 利用切片还可以巧妙地实现列表逆序: 12&gt;&gt;&gt; marxes[::-1]['Harpo', 'Chico', 'Groucho'] 使用append()添加元素至尾部传统的向列表中添加元素的方法是利用append() 函数将元素一个个添加到尾部。 123&gt;&gt;&gt; marxes.append('Zeppo')&gt;&gt;&gt; marxes['Groucho', 'Chico', 'Harpo', 'Zeppo'] 使用extend()或+=合并列表使用 extend()可以将一个列表合并到另一个列表中。 12345&gt;&gt;&gt; marxes = ['Groucho', 'Chico', 'Harpo', 'Zeppo'] &gt;&gt;&gt; others = ['Gummo', 'Karl']&gt;&gt;&gt; marxes.extend(others)&gt;&gt;&gt; marxes['Groucho', 'Chico', 'Harpo', 'Zeppo', 'Gummo', 'Karl'] 也可以使用+=: 12345&gt;&gt;&gt; marxes = ['Groucho', 'Chico', 'Harpo', 'Zeppo'] &gt;&gt;&gt; others = ['Gummo', 'Karl']&gt;&gt;&gt; marxes += others&gt;&gt;&gt; marxes['Groucho', 'Chico', 'Harpo', 'Zeppo', 'Gummo', 'Karl'] 如果错误地使用了 append()，那么 others 会被当成一个单独的元素进行添加，而不是将其中的内容进行合并: 12345&gt;&gt;&gt; marxes = ['Groucho', 'Chico', 'Harpo', 'Zeppo'] &gt;&gt;&gt; others = ['Gummo', 'Karl']&gt;&gt;&gt; marxes.append(others)&gt;&gt;&gt; marxes['Groucho', 'Chico', 'Harpo', 'Zeppo', ['Gummo', 'Karl']] 这个例子再次体现了列表可以包含不同类型的元素。上面的列表包含了四个字符串元素以及一个含有两个字符串的列表元素。 使用insert()在指定位置插入元素append() 函数只能将新元素插入到列表尾部，而使用insert()可以将元素插入到列表的任 意位置。 指定偏移量为 0 可以插入列表头部。如果指定的偏移量超过了尾部，则会插入到 列表最后，就如同 append()一样，这一操作不会产生 Python 异常。 123456&gt;&gt;&gt; marxes.insert(3, 'Gummo')&gt;&gt;&gt; marxes['Groucho', 'Chico', 'Harpo', 'Gummo', 'Zeppo']&gt;&gt;&gt; marxes.insert(10, 'Karl')&gt;&gt;&gt; marxes['Groucho', 'Chico', 'Harpo', 'Gummo', 'Zeppo', 'Karl'] 使用del删除指定位置的元素123&gt;&gt;&gt; del marxes[-1]&gt;&gt;&gt; marxes['Groucho', 'Chico', 'Harpo', 'Gummo', 'Zeppo'] del 是 Python 语句，而不是列表方法——无法通过 marxes[-2].del() 进行调 用。 del 就像是赋值语句(=)的逆过程:它将一个 Python 对象与它的名字 分离。如果这个对象无其他名称引用，则其占用空间也被会清除。 使用remove()删除具有指定值的元素如果不确定或不关心元素在列表中的位置，可以使用 remove() 根据指定的值删除元素。再见了，Gummo: 1234&gt;&gt;&gt; marxes = ['Groucho', 'Chico', 'Harpo', 'Gummo', 'Zeppo'] &gt;&gt;&gt; marxes.remove('Gummo')&gt;&gt;&gt; marxes['Groucho', 'Chico', 'Harpo', 'Zeppo'] 使用pop()获取并删除指定位置的元素使用pop() 同样可以获取列表中指定位置的元素，但在获取完成后，该元素会被自动删除。 如果你为pop() 指定了偏移量，它会返回偏移量对应位置的元素; 如果不指定，则默认使 用 -1。 因此，pop(0) 将返回列表的头元素，而 pop() 或 pop(-1) 则会返回列表的尾元素: 123456789&gt;&gt;&gt; marxes = ['Groucho', 'Chico', 'Harpo', 'Zeppo'] &gt;&gt;&gt; marxes.pop()'Zeppo'&gt;&gt;&gt; marxes['Groucho', 'Chico', 'Harpo'] &gt;&gt;&gt; marxes.pop(1)'Chico'&gt;&gt;&gt; marxes['Groucho', 'Harpo'] 使用index()查询具有特定值的元素位置如果想知道等于某一个值的元素位于列表的什么位置，可以使用 index() 函数进行查询: 123&gt;&gt;&gt; marxes = ['Groucho', 'Chico', 'Harpo', 'Zeppo'] &gt;&gt;&gt; marxes.index('Chico')1 使用in判断值是否存在判断一个值是否存在于给定的列表中有许多方式，其中最具有 Python 风格的是使用 in 12345&gt;&gt;&gt; marxes = ['Groucho', 'Chico', 'Harpo', 'Zeppo'] &gt;&gt;&gt; 'Groucho' in marxesTrue&gt;&gt;&gt; 'Bob' in marxesFalse 同一个值可能出现在列表的多个位置，但只要至少出现一次，in 就会返回 True: 123&gt;&gt;&gt; words = ['a', 'deer', 'a' 'female', 'deer'] &gt;&gt;&gt; 'deer' in wordsTrue 如果经常需要判断一个值是否存在于一个列表中，但并不关心列表中元素之 间的顺序，那么使用 Python 集合进行存储和查找会是更好的选择 使用count()记录特定值出现的次数使用count() 可以记录某一个特定值在列表中出现的次数: 123456789&gt;&gt;&gt; marxes = ['Groucho', 'Chico', 'Harpo'] &gt;&gt;&gt; marxes.count('Harpo')1&gt;&gt;&gt; marxes.count('Bob')0&gt;&gt;&gt; snl_skit = ['cheeseburger', 'cheeseburger', 'cheeseburger'] &gt;&gt;&gt; snl_skit.count('cheeseburger')3 使用join()转换为字符串join()一种新的使用方式: 123&gt;&gt;&gt; marxes = ['Groucho', 'Chico', 'Harpo']&gt;&gt;&gt; ', '.join(marxes)'Groucho, Chico, Harpo' join()函数的参数是字符串或者其他可迭代的包含字符串的序列(例如上面例 子中的字符串列表)，它的输出是一个字符串。 试着这样来记忆join() 的调用顺序: join() 是 split() 的逆过程，如下所示: 12345678910&gt;&gt;&gt; friends = ['Harry', 'Hermione', 'Ron'] &gt;&gt;&gt; separator = ' * '&gt;&gt;&gt; joined = separator.join(friends)&gt;&gt;&gt; joined'Harry * Hermione * Ron'&gt;&gt;&gt; separated = joined.split(separator) &gt;&gt;&gt; separated['Harry', 'Hermione', 'Ron']&gt;&gt;&gt; separated == friendsTrue 使用sort()重新排列元素在实际应用中，经常需要将列表中的元素按值排序，而不是按照偏移量排序。Python 为此 提供了两个函数: 列表方法 sort() 会对原列表进行排序，改变原列表内容; 通用函数 sorted() 则会返回排好序的列表副本，原列表内容不变。 如果列表中的元素都是数字，它们会默认地被排列成从小到大的升序。 如果元素都是字符 串，则会按照字母表顺序排列: 1234&gt;&gt;&gt; marxes = ['Groucho', 'Chico', 'Harpo'] &gt;&gt;&gt; sorted_marxes = sorted(marxes)&gt;&gt;&gt; sorted_marxes['Chico', 'Groucho', 'Harpo'] sorted_marxes 是一个副本，它的创建并不会改变原始列表的内容: 12&gt;&gt;&gt; marxes['Groucho', 'Chico', 'Harpo'] 但对 marxes 列表调用列表函数 sort()则会改变它的内容: 123&gt;&gt;&gt; marxes.sort()&gt;&gt;&gt; marxes['Chico', 'Groucho', 'Harpo'] 当列表中的所有元素都是同一种类型时(例如 marxes 中都是字符串)，sort() 会正常工 作。 有些时候甚至多种类型也可——例如整型和浮点型——只要它们之间能够自动地互相 转换: 1234&gt;&gt;&gt; numbers = [2, 1, 4.0, 3]&gt;&gt;&gt; numbers.sort()&gt;&gt;&gt; numbers[1, 2, 3, 4.0] 默认的排序是升序的，通过添加参数reverse=True 可以改变为降序排列: 1234&gt;&gt;&gt; numbers = [2, 1, 4.0, 3]&gt;&gt;&gt; numbers.sort(reverse=True)&gt;&gt;&gt; numbers[4.0, 3, 2, 1] 使用len()获取长度len()可以返回列表长度: 123&gt;&gt;&gt; marxes = ['Groucho', 'Chico', 'Harpo'] &gt;&gt;&gt; len(marxes)3 使用=赋值，使用copy()复制如果将一个列表赋值给了多个变量，改变其中的任何一处会造成其他变量对应的值也被修改，如下所示: 123456789&gt;&gt;&gt; a = [1, 2, 3]&gt;&gt;&gt; a[1, 2, 3]&gt;&gt;&gt; b = a&gt;&gt;&gt; b[1, 2, 3]&gt;&gt;&gt; a[0] = 'surprise' &gt;&gt;&gt; a['surprise', 2, 3] 现在，b 的值是什么?它会保持 [1, 2, 3]，还是改变为 [‘surprise’, 2, 3] ?试一试: 12&gt;&gt;&gt; b['surprise', 2, 3] b 与 a 实际上指向的是同一个对象，因此，无论我们是通过 a 还是通过 b 来修改列表的内容，其结果都会作用于双方: 1234567&gt;&gt;&gt; b['surprise', 2, 3]&gt;&gt;&gt; b[0] = 'I hate surprises' &gt;&gt;&gt; b['I hate surprises', 2, 3] &gt;&gt;&gt; a['I hate surprises', 2, 3] 通过下面任意一种方法，都可以将一个列表的值复制到另一个新的列表中: 列表 copy() 函数 list() 转换函数 列表分片[:] 测试初始时我们的列表叫作 a，然后利用copy() 函数创建 b，利用list() 函数创建 c，并 使用列表分片创建 d: 1234&gt;&gt;&gt; a = [1, 2, 3]&gt;&gt;&gt; b = a.copy()&gt;&gt;&gt; c = list(a)&gt;&gt;&gt; d = a[:] 再次注意，在这个例子中，b、c、d 都是 a 的复制:它们是自身带有值的新对象，与原始 的 a 所指向的列表对象 [1, 2, 3] 没有任何关联。改变 a 不影响 b、c 和 d 的复制。 使用()创建元组可以用 () 创建一个空元组: 123&gt;&gt;&gt; empty_tuple = ()&gt;&gt;&gt; empty_tuple() 创建包含一个或多个元素的元组时，每一个元素后面都需要跟着一个逗号，即使只包含一 个元素也不能省略: 123&gt;&gt;&gt; one_marx = 'Groucho', &gt;&gt;&gt; one_marx('Groucho',) 如果创建的元组所包含的元素数量超过 1，最后一个元素后面的逗号可以省略: 123&gt;&gt;&gt; marx_tuple = 'Groucho', 'Chico', 'Harpo' &gt;&gt;&gt; marx_tuple('Groucho', 'Chico', 'Harpo') Python 的交互式解释器输出元组时会自动添加一对圆括号。你并不需要这么做——定义元 组真正靠的是每个元素的后缀逗号； 但如果你习惯添加一对括号也无可厚非。可以用括 号将所有元素包裹起来，这会使得程序更加清晰: 123&gt;&gt;&gt; marx_tuple = ('Groucho', 'Chico', 'Harpo') &gt;&gt;&gt; marx_tuple('Groucho', 'Chico', 'Harpo') 可以一口气将元组赋值给多个变量: 12345678&gt;&gt;&gt; marx_tuple = ('Groucho', 'Chico', 'Harpo') &gt;&gt;&gt; a, b, c = marx_tuple&gt;&gt;&gt; a'Groucho'&gt;&gt;&gt; b'Chico' &gt;&gt;&gt; c 'Harpo' 有时这个过程被称为元组解包。 可以利用元组在一条语句中对多个变量的值进行交换，而不需要借助临时变量: 1234567&gt;&gt;&gt; password = 'swordfish'&gt;&gt;&gt; icecream = 'tuttifrutti'&gt;&gt;&gt; password, icecream = icecream, password &gt;&gt;&gt; password'tuttifrutti'&gt;&gt;&gt; icecream'swordfish' tuple() 函数可以用其他类型的数据来创建元组: 123&gt;&gt;&gt; marx_list = ['Groucho', 'Chico', 'Harpo'] &gt;&gt;&gt; tuple(marx_list)('Groucho', 'Chico', 'Harpo') 元组与列表在许多地方都可以用元组代替列表，但元组的方法函数与列表相比要少一些， 元组没有 append()、insert()，等等， 因为一旦创建元组便无法修改。既然列表更加灵活，那为 什么不在所有地方都使用列表呢?原因如下所示: 元组占用的空间较小 你不会意外修改元组的值 可以将元组用作字典的键 命名元组可以作为对象的替代 函数的参数是以元组形式传递的]]></content>
      <categories>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Python字符串]]></title>
    <url>%2F2018%2F02%2F05%2FPython%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[使用引号创建将一系列字符包裹在一对单引号或一对双引号中即可创建字符串，就像下面这样： 1234&gt;&gt;&gt; 'Snap' 'Snap'&gt;&gt;&gt; "Crackle" 'Crackle' 交互式解释器输出的字符串永远是用单引号包裹的，但无论使用哪种引号，Python 对字符 串的处理方式都是一样的，没有任何区别。 既然如此，为什么要使用两种引号?这么做的好处是可以创建本身就包含引号的字符串， 而不用使用转义符。可以在双引号包裹的字符串中使用单引号，或者在单引号包裹的字符 串中使用双引号： 1234567&gt;&gt;&gt; "'Nay,' said the naysayer.""'Nay,' said the naysayer."&gt;&gt;&gt; 'The rare double quote in captivity: ".''The rare double quote in captivity: ".'&gt;&gt;&gt; 'A "two by four" is actually 1 1⁄2" × 3 1⁄2".''A "two by four is" actually 1 1⁄2" × 3 1⁄2".'&gt;&gt;&gt; "'There's the man that shot my paw!' cried the limping hound." "'There's the man that shot my paw!' cried the limping hound." 你还可以使用连续三个单引号 &#39;&#39;&#39;，或者三个双引号 &quot;&quot;&quot; 创建字符串： 1234&gt;&gt;&gt; '''Boom!''' 'Boom'&gt;&gt;&gt; """Eek!""" 'Eek!' 三元引号在创建短字符串时没有什么特殊用处。它多用于创建多行字符串： 123456&gt;&gt;&gt; poem = '''There was a Young Lady of Norway,... Who casually sat in a doorway;... When the door squeezed her flat,... She exclaimed, "What of that?"... This courageous Young Lady of Norway.'''&gt;&gt;&gt; 在三元引号包裹的字符串中，每行的换行符以及行首或行末的空格都会被保留： 1234567891011&gt;&gt;&gt; poem2 = '''I do not like thee, Doctor Fell.... The reason why, I cannot tell.... But this I know, and know full well:... I do not like thee, Doctor Fell.... '''&gt;&gt;&gt; print(poem2)I do not like thee, Doctor Fell. The reason why, I cannot tell. But this I know, and know full well: I do not like thee, Doctor Fell.&gt;&gt;&gt; 值得注意的是，print() 函数的输出与交互式解释器的自动响应输出存在一些差异： 12&gt;&gt;&gt; poem2'I do not like thee, Doctor Fell.\n The reason why, I cannot tell.\n But this I know, and know full well:\n I do not like thee, Doctor Fell.\n' print()会把包裹字符串的引号截去，仅输出其实际内容，易于阅读。它还会自动地在各 个输出部分之间添加空格，并在所有输出的最后添加换行符： 12&gt;&gt;&gt; print(99, 'bottles', 'would be enough.') 99 bottles would be enough. 如果你不希望print() 自动添加空格或换行，随后将学会如何避免它们。 最后要指出的是 Python 允许空串的存在，它不包含任何字符且完全合法： 12345678&gt;&gt;&gt; ''''&gt;&gt;&gt; ""''&gt;&gt;&gt; ''''''''&gt;&gt;&gt; """"""'' 为什么会用到空字符串？有些时候你想要创建的字符串可能源自另一字符串的内容，这时 需要先创建一个空白的模板，也就是一个空字符串。 123456&gt;&gt;&gt; bottles = 99&gt;&gt;&gt; base = ''&gt;&gt;&gt; base += 'current inventory: ' &gt;&gt;&gt; base += str(bottles)&gt;&gt;&gt; base'current inventory: 99' 字符串是一个序列字符串是由字符组成的序列。你可以用括号运算符一次访问一个字符: 12&gt;&gt;&gt; fruit = 'banana'&gt;&gt;&gt; letter = fruit[1] 使用str()进行类型转换使用 str() 可以将其他 Python 数据类型转换为字符串： 123456&gt;&gt;&gt; str(98.6) '98.6'&gt;&gt;&gt; str(1.0e4) '10000.0'&gt;&gt;&gt; str(True) 'True' 当你调用 print() 函数或者进行字符串差值(string interpolation)时，Python 内部会自动 使用 str() 将非字符串对象转换为字符串。 使用\转义Python 允许你对某些字符进行转义操作，以此来实现一些难以单纯用字符描述的效果。在 字符的前面添加反斜线符号\ 会使该字符的意义发生改变。最常见的转义符是 \n，它代表 换行符，便于你在一行内创建多行字符串。 123456&gt;&gt;&gt; palindrome = 'A man,\nA plan,\nA canal:\nPanama.' &gt;&gt;&gt; print(palindrome)A man,A plan,A canal:Panama. 转义符 \t(tab 制表符)常用于对齐文本： 123456&gt;&gt;&gt; print('\tabc') abc&gt;&gt;&gt; print('a\tbc') a bc&gt;&gt;&gt; print('ab\tc') ab c 有时你可能还会用到 \&#39; 和 \&quot; 来表示单、双引号，尤其当该字符串由相同类型的引号包裹时: 1234567&gt;&gt;&gt; testimony = "\"I did nothing!\" he said. \"Not that either! Or the other thing.\""&gt;&gt;&gt; print(testimony)"I did nothing!" he said. "Not that either! Or the other thing."&gt;&gt;&gt; fact = "The world's largest rubber duck was 54'2\" by 65'7\" by 105'"&gt;&gt;&gt; print(fact)The world's largest rubber duck was 54'2" by 65'7" by 105' 如果你需要输出一个反斜线字符，连续输入两个反斜线即可: 123&gt;&gt;&gt; speech = 'Today we honor our friend, the backslash: \\.' &gt;&gt;&gt; print(speech)Today we honor our friend, the backslash: \. 使用+拼接在 Python 中，你可以使用 + 将多个字符串或字符串变量拼接起来，就像下面这样: 12&gt;&gt;&gt; 'Release the kraken! ' + 'At once!' 'Release the kraken! At once!' 也可以直接将一个字面字符串(非字符串变量)放到另一个的后面直接实现拼接: 12&gt;&gt;&gt; "My word! " "A gentleman caller!"'My word! A gentleman caller!' 进行字符串拼接时，Python 并不会自动为你添加空格，需要显示定义。但当我们调用print() 进行打印时，Python 会在各个参数之间自动添加空格并在结尾添加换行符: 1234567&gt;&gt;&gt; a = 'Duck.'&gt;&gt;&gt; b = a&gt;&gt;&gt; c = 'Grey Duck!' &gt;&gt;&gt; a + b + c 'Duck.Duck.Grey Duck!' &gt;&gt;&gt; print(a, b, c) Duck. Duck. Grey Duck! 使用*复制使用 * 可以进行字符串复制。 1234&gt;&gt;&gt; start = 'Na ' * 4 + '\n'&gt;&gt;&gt; middle = 'Hey ' * 3 + '\n'&gt;&gt;&gt; end = 'Goodbye.'&gt;&gt;&gt; print(start + start + middle + end) 使用[]提取字符在字符串名后面添加 []，并在括号里指定偏移量可以提取该位置的单个字符。第一个字符 (最左侧)的偏移量为0，下一个是1，以此类推。最后一个字符(最右侧)的偏移量也可以用 -1 表示，这样就不必从头数到尾。偏移量从右到左紧接着为 -2、-3，以此类推。 12345678910111213&gt;&gt;&gt; letters = 'abcdefghijklmnopqrstuvwxyz' &gt;&gt;&gt; letters[0]'a'&gt;&gt;&gt; letters[1]'b'&gt;&gt;&gt; letters[-1] 'z'&gt;&gt;&gt; letters[-2] 'y'&gt;&gt;&gt; letters[25] 'z'&gt;&gt;&gt; letters[5] 'f' 字符串是不可变的由于字符串是不可变的，因此你无法直接插入字符或改变指定位置的字符 12345&gt;&gt;&gt; name = 'Henny'&gt;&gt;&gt; naume[0] = 'P'Traceback (most recent call last):File "&lt;stdin&gt;", line 1, in &lt;module&gt;TypeError: 'str' object does not support item assignment 为了改变字符串，我们需要组合使用一些字符串函数，例如replace()，以及分片操作: 12345&gt;&gt;&gt; name = 'Henny'&gt;&gt;&gt; name.replace('H', 'P') 'Penny'&gt;&gt;&gt; 'P' + name[1:]'Penny' 使用[start:end:step]分片分片操作(slice)可以从一个字符串中抽取子字符串(字符串的一部分)。 我们使用一对方 括号、起始偏移量 start、终止偏移量 end 以及可选的步长 step 来定义一个分片。其中一 些可以省略。 分片得到的子串包含从 start 开始到 end 之前的全部字符。 [:] 提取从开头到结尾的整个字符串 [start:] 从 start 提取到结尾 [:end] 从开头提取到 end - 1 [start:end] 从 start 提取到 end - 1 [start:end:step] 从 start 提取到 end - 1，每 step 个字符提取一个 偏移量从左至右从 0、1 开始，依次增加； 从右至左从-1、-2 开始，依次减 小。 如果省略 start，分片会默认使用偏移量 0(开头)； 如果省略 end，分片会默认使用 偏移量 -1(结尾)。 我们来创建一个由小写字母组成的字符串: 1&gt;&gt;&gt; letters = 'abcdefghijklmnopqrstuvwxyz' 仅仅使用: 分片等价于使用 0 : -1(也就是提取整个字符串): 12&gt;&gt;&gt; letters[:] 'abcdefghijklmnopqrstuvwxyz' 下面是一个从偏移量 20 提取到字符串结尾的例子: 12&gt;&gt;&gt; letters[20:]'uvwxyz' 下一个例子提取了偏移量从 12 到 14 的字符: 12&gt;&gt;&gt; letters[12:15] 'mno' 提取最后三个字符: 12&gt;&gt;&gt; letters[-3:] 'xyz' 下面一个例子提取了从偏移量为 18 的字符到倒数第 4 个字符。 注意与上一个例子的区别: 当偏移量 -3 作为开始位置时，将获得字符 x;而当它作为终止位置时，分片实际上会在偏 移量 -4 处停止，也就是提取到字符 w: 12&gt;&gt;&gt; letters[18:-3] 'stuvw' 接下来，试着提取从倒数第 6 个字符到倒数第 3 个字符: 12&gt;&gt;&gt; letters[-6:-2]'uvwx' 如果你需要的步长不是默认的 1，可以在第二个冒号后面进行指定。 从开头提取到结尾，步长设为 7: 12&gt;&gt;&gt; letters[::7] 'ahov' 从偏移量 4 提取到偏移量 19，步长设为 3: 12&gt;&gt;&gt; letters[4:20:3]'ehknqt' 从偏移量 19 提取到结尾，步长设为 4: 12&gt;&gt;&gt; letters[19::4] 'tx' 从开头提取到偏移量 20，步长设为 5: 12&gt;&gt;&gt; letters[:21:5]'afkpu' 记住，分片中 end 的偏移量需要比实际提取的最后一个字符的偏移量多 1。 如果指定的步长为负数，机智的 Python 还会从右到左反 向进行提取操作。 下面这个例子便从右到左以步长为 1 进行提取: 12&gt;&gt;&gt; letters[-1::-1] 'zyxwvutsrqponmlkjihgfedcba' 事实上，你可以将上面的例子简化为下面这种形式，结果完全一致: 12&gt;&gt;&gt; letters[::-1] 'zyxwvutsrqponmlkjihgfedcba' 分片操作对于无效偏移量的容忍程度要远大于单字符提取操作。在分片中，小于起始位置的 偏移量会被当作 0，大于终止位置的偏移量会被当作 -1。 提取倒数 50 个字符: 12&gt;&gt;&gt; letters[-50:]'abcdefghijklmnopqrstuvwxyz' 提取从倒数第 51 到倒数第 50 个字符: 12&gt;&gt;&gt; letters[-51:-50]'' 从开头提取到偏移量为 69 的字符: 12&gt;&gt;&gt; letters[:70]'abcdefghijklmnopqrstuvwxyz' 从偏移量为 70 的字符提取到偏移量为 71 的字符: 12&gt;&gt;&gt; letters[70:71]'' 使用len()获得长度len() 函数可用于计算字符串包含的字符数: 12345&gt;&gt;&gt; len(letters)26&gt;&gt;&gt; empty = ""&gt;&gt;&gt; len(empty)0 也可以对其他的序列类型使用 len() 使用split()分割与广义函数len() 不同，有些函数只适用于字符串类型。使用内置的字符串函数 split()可以基于分隔符将字符串分割成由若干子串组成的列表。 123&gt;&gt;&gt; todos = 'get gloves,get mask,give cat vitamins,call ambulance' &gt;&gt;&gt; todos.split(',')['get gloves', 'get mask', 'give cat vitamins', 'call ambulance'] 如 果不指定分隔符，那么 split() 将默认使用空白字符——换行符、空格、制表符。 12&gt;&gt;&gt; todos.split()['get', 'gloves,get', 'mask,give', 'cat', 'vitamins,call', 'ambulance'] 使用join()合并join() 函数与 split()函数正好相反：它将包含若干子串的列表分 解，并将这些子串合成一个完整的大的字符串。 join()的调用顺序看起来有点别扭，与 split() 相反，你需要首先指定粘合用的字符串，然后再指定需要合并的列表：string. join(list)。 因此，为了将列表 lines 中的多个子串合并成完整的字符串，我们应该使用语 句：&#39;\n&#39;.join(lines)。 下面的例子将列表中的名字通过逗号及空格粘合在一起: 1234&gt;&gt;&gt; crypto_list = ['Yeti', 'Bigfoot', 'Loch Ness Monster']&gt;&gt;&gt; crypto_string = ', '.join(crypto_list)&gt;&gt;&gt; print('Found and signing book deals:', crypto_string) Found and signing book deals: Yeti, Bigfoot, Loch Ness Monster 其他常用字符串相关函数我们的测试对象是下面的字符串 123456&gt;&gt;&gt; poem = '''All that doth flow we cannot liquid nameOr else would fire and water be the same;But that is liquid which is moist and wetFire that property can never get.Then 'tis not cold that doth the fire put out But 'tis the wet that makes it die, no doubt.''' 这首诗有多少个字符呢?(计入空格和换行符。) 12&gt;&gt;&gt; len(poem)250 这首诗是不是以 All 开头呢? 12&gt;&gt;&gt; poem.startswith('All')True 它是否以 That’s all, folks!? 结尾? 12&gt;&gt;&gt; poem.endswith('That\'s all, folks!') False 查一查诗中第一次出现单词 the 的位置(偏移量): 123&gt;&gt;&gt; word = 'the' &gt;&gt;&gt; poem.find(word) 73 以及最后一次出现 the 的偏移量 : 12&gt;&gt;&gt; poem.rfind(word)214 the 在这首诗中出现了多少次? 12&gt;&gt;&gt; poem.count(word)3 诗中出现的所有字符都是字母或数字吗? 12&gt;&gt;&gt; poem.isalnum()False 并非如此，诗中还包括标点符号。 大小写与对齐方式我们的测试字符串如下所示: 1&gt;&gt;&gt; setup = 'a duck goes into a bar...' 将字符串收尾的. 都删除掉: 12&gt;&gt;&gt; setup.strip('.')'a duck goes into a bar' 由于字符串是不可变的，上面这些例子实际上没有一个对 setup 真正做了修 改。它们都仅仅是获取了 setup 的值，进行某些操作后将操作结果赋值给了 另一个新的字符串而已。 让字符串首字母变成大写: 12&gt;&gt;&gt; setup.capitalize()'A duck goes into a bar...' 让所有单词的开头字母变成大写: 12&gt;&gt;&gt; setup.title()'A Duck Goes Into A Bar...' 让所有字母都变成大写: 12&gt;&gt;&gt; setup.upper()'A DUCK GOES INTO A BAR...' 将所有字母转换成小写: 12&gt;&gt;&gt; setup.lower()'a duck goes into a bar...' 将所有字母的大小写转换: 12&gt;&gt;&gt; setup.swapcase()'a DUCK GOES INTO A BAR...' 再来看看与格式排版相关的函数。这里，我们假设例子中的字符串被排版在指定长度(这 里是 30 个字符)的空间里。 在 30 个字符位居中: 12&gt;&gt;&gt; setup.center(30)' a duck goes into a bar... ' 左对齐: 12&gt;&gt;&gt; setup.ljust(30)'a duck goes into a bar... ' 右对齐: 12&gt;&gt;&gt; setup.rjust(30)' a duck goes into a bar...' 使用replace()替换使用 replace() 函数可以进行简单的子串替换。 你需要传入的参数包括：需要被替换的子 串，用于替换的新子串，以及需要替换多少处。最后一个参数如果省略则默认只替换第一次出现的位置: 12&gt;&gt;&gt; setup.replace('duck', 'marmoset') 'a marmoset goes into a bar...' 修改最多 100 处： 12&gt;&gt;&gt; setup.replace('a ', 'a famous ', 100)'a famous duck goes into a famous bar...' 当你准确地知道想要替换的子串是什么样子时，replace() 是个非常不错的选择。但使用 时一定要小心! 在上面第二个例子中，如果我们粗心地把需要替换的子串写成了单个字符 的 ‘a’ 而不是两个字符的 ‘a ‘(a 后面跟着一个空格)的话，会错误地将所有单词中出现 的 a 也一并替换了: 12&gt;&gt;&gt; setup.replace('a', 'a famous', 100)'a famous duck goes into a famous ba famousr...']]></content>
      <categories>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Python学习笔记之变量和内置数据类型]]></title>
    <url>%2F2018%2F02%2F04%2FPython%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%8F%98%E9%87%8F%E5%92%8C%E5%86%85%E7%BD%AE%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[Python 里一切都是以对象(object)的形式存在的。 变量变量的命名规则 变量名只能包含字母、数字和下划线。 变量名不能以数字开头。 不能使用以下保留的关键字作为变量名： 1234567False class finally is returnNone continue for lambda tryTrue def from nonlocal whileand del global not withas elif if or yieldassert else import passbreak except in raise 内置数据类型在 Python 中您并不需要声明变量的数据类型。Python 根据每 个变量的初始赋值情况分析其类型，并在内部对其进行跟踪。 type()函数查看对象类型在 Python 中，如果想知道一个对象(例如一个变量或者一个字面值)的类型，可以使用语 句：type( thing )。 12345678910&gt;&gt;&gt; type(a) &lt;class 'int'&gt; &gt;&gt;&gt; type(b) &lt;class 'int'&gt; &gt;&gt;&gt; type(58) &lt;class 'int'&gt; &gt;&gt;&gt; type(99.9)&lt;class 'float'&gt; &gt;&gt;&gt; type('abc') &lt;class 'str'&gt; isinstance() 函数判断某个值或变量是否为给定某个类型。12&gt;&gt;&gt; isinstance(1, int) True 布尔型Python 有两个被巧妙地命名为 True 和 False 的常量，可用于对布尔类型的直接赋值。 数值型Python 本身支持整数(比如 5 和 1000000000)以及浮点数(比如 3.1416、14.99 和 1.87e4)。你可以对这些数字进行下表中的计算。 运算符 描述 示例 运算结果 + 加法 5 + 8 13 - 减法 90 – 10 80 * 乘法 4 * 7 28 / 除法 7 / 2 3.5 // 取整除（返回商的整数部分） 7 // 2 3 % 模（求余） 7 % 3 1 ** 幂 3 ** 4 81 整数int任何仅含数字的序列在 Python 中都被认为是整数: 12&gt;&gt;&gt; 55 你可以单独使用数字零(0): 12&gt;&gt;&gt; 00 但不能把它作为前缀放在其他数字前面: 123456&gt;&gt;&gt; 05 File "&lt;stdin&gt;", line 1 05 ^SyntaxError: invalid token&gt;&gt;&gt; 一个数字序列定义了一个正整数。你也可以显式地在前面加上正号 +，这不会使数字发生 任何改变: 1234&gt;&gt;&gt; 123123&gt;&gt;&gt; +123123 在数字前添加负号 - 可以定义一个负数: 12&gt;&gt;&gt; -123-123 除法运算比较有意思，可能与你预期的有些出入，因为 Python 里有两种除法: / 用来执行浮点除法(十进制小数) // 用来执行整数除法(整除) 与其他语言不同，在 Python 中即使运算对象是两个整数，使用 / 仍会得到浮点型的结果: 12&gt;&gt;&gt; 9 / 5 1.8 使用整除运算得到的是一个整数，余数会被截去: 12&gt;&gt;&gt; 9 // 5 1 如果除数为 0，任何一种除法运算都会产生 Python 异常: 123456789&gt;&gt;&gt; 5 / 0Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;ZeroDivisionError: division by zero&gt;&gt;&gt; 7 // 0Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;ZeroDivisionError: integer division or modulo by zero&gt;&gt;&gt; Python 还支持以下写法 1234&gt;&gt;&gt; a = 95&gt;&gt;&gt; a -= 3&gt;&gt;&gt; a92 使用下面的方法可以同时得到余数和商: 12&gt;&gt;&gt; divmod(9,5)(1, 4) 上面的代码出现了一些你没见过的新东西:一个叫作 divmod 的函数。这个函数接受了两个 整数:9 和 5，并返回了一个包含两个元素的结果，我们称这种结构为元组(tuple)。 运算优先级建议总是使用括号来保证运算顺序与我们期望的一致: 12&gt;&gt;&gt; 2 + (3 * 4)14 基数在 Python 中，整数默认使用十进制数，除非你在数字前添加前缀，显式地指 定使用其他基数(base)。 在 Python 中，除十进制外你还可以使用其他三种进制的数字: 0b 或 0B 代表二进制(以 2 为底) 0o 或 0O 代表八进制(以 8 为底) 0x 或 0X 代表十六进制(以 16 为底) Python 解释器会打印出它们对应的十进制整数： 123456&gt;&gt;&gt; 0b102&gt;&gt;&gt; 0o108&gt;&gt;&gt; 0x1016 使用int()函数转换为整型我们可以方便地使用 int() 函数将其他的 Python 数据类型转换为整型。它会保留传入数据的整数部分并舍去小数部分。 Python 里最简单的数据类型是布尔型，它只有两个可选值：True 和 False。当转换为整数时，它们分别代表 1 和 0： 1234&gt;&gt;&gt; int(True)1&gt;&gt;&gt; int(False)0 当将浮点数转换为整数时，int() 将进行取整，而不是四舍五入。 1234&gt;&gt;&gt; int(98.6)98&gt;&gt;&gt; int(1.0e4)10000 也可以将仅包含数字和正负号的字符串转换为整数： 123456&gt;&gt;&gt; int('99') 99&gt;&gt;&gt; int('-23') -23&gt;&gt;&gt; int('+12') 12 将一个整数转换为整数没有太多意义，这既不会产生任何改变也不会造成任何损失： 12&gt;&gt;&gt; int(12345)12345 如果你试图将一个与数字无关的类型转化为整数，会得到一个异常： 12345678910&gt;&gt;&gt; int('asfd')Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;ValueError: invalid literal for int() with base 10: 'asfd'&gt;&gt;&gt; &gt;&gt;&gt; int('')Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;ValueError: invalid literal for int() with base 10: ''&gt;&gt;&gt; int()可以接受浮点数或由数字组成的字符串，但无法接受包含小数点或指数的字符串： 123456789&gt;&gt;&gt; int('98.6')Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;ValueError: invalid literal for int() with base 10: '98.6'&gt;&gt;&gt; int('1.0e4')Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;ValueError: invalid literal for int() with base 10: '1.0e4'&gt;&gt;&gt; 如果混合使用多种不同的数字类型进行计算，Python 会自动地进行类型转换： 12&gt;&gt;&gt; 4 + 7.011.0 与整数或浮点数混合使用时，布尔型的 False 会被当作 0 或 0.0，Ture 会被当作 1 或 1.0： 1234&gt;&gt;&gt; True + 23&gt;&gt;&gt; False + 5.05.0 一个int型有多大在 Python 2 里，一个 int 型包含 32 位，可以存储从 -2 147 483 648 到 2 147 483 647 的整数。 一个 long 型会占用更多的空间:64 位，可以存储从 -9 223 372 036 854 775 808 到 9 223 372 036 854 775 807 的整数。 到了 Python 3，long 类型已不复存在，而 int 类型变为可以存储任意大小的整数，甚至超 过 64 位。因此，你可以进行像下面一样计算 (10**100 被赋值给名为 googol 的变量，这是 Google 最初的名字，但由于其拼写困难而被现在的名字所取代)： 12345&gt;&gt;&gt;&gt;&gt;&gt; googol = 10**100&gt;&gt;&gt; googol 10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000&gt;&gt;&gt; googol * googol100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000 在许多其他编程语言中，进行类似上面的计算会造成整数溢出，这是因为计算中的数字或 结果需要的存储空间超过了计算机所提供的(例如 32 位或 64 位)。在程序编写中，溢出 会产生许多负面影响。而 Python 在处理超大数计算方面不会产生任何错误，这也是它的一个加分点。 浮点数float使用 float() 函数可以将其他数字类型转换为浮点型。 1234&gt;&gt;&gt; float(True)1.0&gt;&gt;&gt; float(False)0.0 将整数转换为浮点数 1234&gt;&gt;&gt; float(98) 98.0&gt;&gt;&gt; float('99') 99.0 此外，也可以将包含有效浮点数(数字、正负号、小数点、指数及指数的前缀 e)的字符 串转换为真正的浮点型数字： 123456&gt;&gt;&gt; float('98.6') 98.6&gt;&gt;&gt; float('-1.5') -1.5&gt;&gt;&gt; float('1.0e4') 10000.0 浮点数精确到小数点后 15 位。 12&gt;&gt;&gt; 1.12345678901234567890 1.1234567890123457]]></content>
      <categories>
        <category>Python</category>
      </categories>
  </entry>
</search>
